// █████   ███   █████                       █████                  ███                 █████    █████   █████                      ████   █████   
//░░███   ░███  ░░███                       ░░███                  ░░░                 ░░███    ░░███   ░░███                      ░░███  ░░███    
// ░███   ░███   ░███   ██████   ██████   ███████  █████ ███ █████ ████  ████████    ███████     ░███    ░███   ██████   █████ ████ ░███  ███████  
// ░███   ░███   ░███  ███░░███ ███░░███ ███░░███ ░░███ ░███░░███ ░░███ ░░███░░███  ███░░███     ░███    ░███  ░░░░░███ ░░███ ░███  ░███ ░░░███░   
// ░░███  █████  ███  ░███ ░███░███ ░███░███ ░███  ░███ ░███ ░███  ░███  ░███ ░███ ░███ ░███     ░░███   ███    ███████  ░███ ░███  ░███   ░███    
//  ░░░█████░█████░   ░███ ░███░███ ░███░███ ░███  ░░███████████   ░███  ░███ ░███ ░███ ░███      ░░░█████░    ███░░███  ░███ ░███  ░███   ░███ ███
//    ░░███ ░░███     ░░██████ ░░██████ ░░████████  ░░████░████    █████ ████ █████░░████████       ░░███     ░░████████ ░░████████ █████  ░░█████ 
//     ░░░   ░░░       ░░░░░░   ░░░░░░   ░░░░░░░░    ░░░░ ░░░░    ░░░░░ ░░░░ ░░░░░  ░░░░░░░░         ░░░       ░░░░░░░░   ░░░░░░░░ ░░░░░    ░░░░░  
//                                                                                                                                                 
// © 2021
// @ govindthange
//
// @version=5

//
// @description Woodwind Vault provides reusable functions to support Thange Woodwind Playbook.
//
library("WoodwindVault")

//
// @function determines the highest-high and the lowest-low value for the specified interval.
// @param period int, the time interval.
// @returns float, the highest-high and lowest-low value.
//
export getHighestHighAndLowestLow(int period) => math.avg(ta.lowest(period), ta.highest(period))

//
// @function gets a suitable combination of equilibrium periods for the specified scheme.
// @param scheme string, the name of the scheme.
// @returns 4 float values, a best suited combination of equilibrium periods.
//
export getEquilibriumPeriods(string scheme) =>
    switch scheme
        "Custom" => [0, 0, 0, 0]
        "Standard" => [9, 26, 52, 26]
        "Scalper" => [7, 22, 44, 22]
        "5 Day Week" => [8, 22, 44, 22]
        "Popular" => [9, 30, 60, 30]
        "Ideal" => [10, 30, 60, 30]
        "Trend Finder" => [12, 24, 120, 24]
        "Forflies" => [20, 60, 120, 30]
        =>
            runtime.error("Scheme not supported!")
            [int(na), int(na), int(na), int(na)]


//
// @function projects a one glance view of the entire resistance net faced by the price. It does so by computing different equilibrium points for the price.
// @param shortTermPeriod, the period for computing the short-term equilibrium point.
// @param midTermPeriod, the period for computing the intermediate-term equilibrium point.
// @param longTermPeriod, the period for computing the 2 additional long-term equilibrium points.
// @returns shortTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last shortTermPeriod.
// @returns mideTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last midTermPeriod.
// @returns longTermEquilibriumA float, the midpoint of the shortTermEquilibrium and midTermEquilibrium points.
// @returns longTermEquilibriumB float, the midpoint of highest-high and lowest-low of the candles in last longTermPeriod.
//
export findEquilibrium(int shortTermPeriod, int midTermPeriod, int longTermPeriod) =>
    shortTermEquilirium = getHighestHighAndLowestLow(shortTermPeriod)
    mideTermEquilibrium = getHighestHighAndLowestLow(midTermPeriod)
    longTermEquilibriumA = math.avg(shortTermEquilirium, mideTermEquilibrium)
    longTermEquilibriumB = getHighestHighAndLowestLow(longTermPeriod)
    [shortTermEquilirium, mideTermEquilibrium, longTermEquilibriumA, longTermEquilibriumB]


//
// @function glances over the 2 equilibrium points from moving averages and establishes whether its bullish or bearish.
// @param fast float, the fast moving point.
// @param slow float, the slow moving point.
// @returns string, it is "bullish" if fast moving point is over the slow moving point o/w returns "bearish".
//
export getGlance(float fast, float slow) =>
    float diff = fast - slow
    string view = diff > 0 ? "bullish" : (diff < 0 ? "bearish" : "neutral")
    view


//
// @function determines the placement of price w.r.t the specified resistance/support level.
// @param point float, the price (typically a fast moving average).
// @param level float, the dynamic support/resistance (typically a slow moving average).
// @returns string, the above/below/at position w.r.t level. 
//
export positionRelativeToLevel(float point, float level) =>
    string position = point > level ? "above" : (point < level ? "below" : "at")
    position


//
// @function determines the placement of price w.r.t a range (i.e. a dynamic resistance band).
// @param point float, the price.
// @param fromLevel float, the from-range which is typically a fast moving line.
// @param toLevel float, the to-range which is typically a slow moving line.
// @returns string, the above/below/within range. 
//
export positionRelativeToRange(float price, float fromLevel, float toLevel) =>
    string view = getGlance(fromLevel, toLevel)
    string position = "within"
    if (view == "bullish" and price > fromLevel)
         or (view == "bearish" and price > toLevel)
        position := "above"
    else if (view == "bullish" and price < toLevel)
         or (view == "bearish" and price < fromLevel)
        position := "below"
    else if (view == "neutral" and price > fromLevel)
        position := "above"
    else if (view == "neutral" and price > toLevel)
        position := "above"
    else if (view == "neutral" and price < toLevel)
        position := "below"
    else if (view == "neutral" and price < fromLevel)
        position := "below"
    else
        position := "within"
    position




//░░░█████╗░██╗░░░██╗██╗░░██╗██╗██╗░░░░░██╗░█████╗░██████╗░██╗░░░██╗░░░░███████╗███╗░░██╗░░
//░░██╔══██╗██║░░░██║╚██╗██╔╝██║██║░░░░░██║██╔══██╗██╔══██╗╚██╗░██╔╝░░░░██╔════╝████╗░██║░░
//░░███████║██║░░░██║░╚███╔╝░██║██║░░░░░██║███████║██████╔╝░╚████╔╝░░░░░█████╗░░██╔██╗██║░░
//░░██╔══██║██║░░░██║░██╔██╗░██║██║░░░░░██║██╔══██║██╔══██╗░░╚██╔╝░░░░░░██╔══╝░░██║╚████║░░
//░░██║░░██║╚██████╔╝██╔╝╚██╗██║███████╗██║██║░░██║██║░░██║░░░██║░░░░░░░██║░░░░░██║░╚███║░░
//░░╚═╝░░╚═╝░╚═════╝░╚═╝░░╚═╝╚═╝╚══════╝╚═╝╚═╝░░╚═╝╚═╝░░╚═╝░░░╚═╝░░░░░░░╚═╝░░░░░╚═╝░░╚══╝░░

//
// @function calculates the gains after a position is scaled down.
// @param entry float, the entry price of the short/long position.
// @param exit float, the exit price of the short/long position.
// @param qty float, the quantity by which a position is to be scaled down.
// @param remainingQty float, the remaining quantity before the scale down.
// @param direction int, its -1 for a short position and +1 for a long position.
// @returns _qty float, the quantity by which the position is scaled down.
// @returns _remainingQty float, the remaining quantity after the scale down. 
// @returns _gains float, the profit & loss after the scale down. 
//
export computeExitGains(float entry, float exit, float qty, float remainingQty, int direction) =>
    float _qty = qty
    if (remainingQty <= qty)
        _qty := remainingQty
    _gains = (exit - entry) * _qty * direction
    _remainingQty = remainingQty - _qty
    [_qty, _remainingQty, _gains]

