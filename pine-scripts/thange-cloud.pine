// © 2021
// @ govindthange

//@version=5
indicator("Thange Cloud Playbook", shorttitle="Thange Signals", overlay=true)

// Standard constants
YES = 1.0
NO = 0.0


// Initialize an empty array to store trading parameters
var context = array.new_float(15)

f_set(_key, _val) => array.set(context, _key, _val)

f_get(_key) => array.get(context, _key)

f_getString(_key) => str.tostring(array.get(context, _key))

f_true(_key) => f_get(_key) == YES

f_print(_text) =>
    // Create label on the first bar.
    var _label = label.new(bar_index, na, _text, xloc.bar_index, yloc.price, color(na), label.style_none, color.white, size.small, text.align_left)
    // On next bars, update the label's x and y position, and the text it displays.
    label.set_xy(_label, bar_index, ta.highest(10)[1])
    label.set_text(_label, _text)

// Create string format template to restrict SL precision to ticks.
f_tickFormat() =>
    _s = str.tostring(syminfo.mintick)
    _s := str.replace_all(_s, "25", "00")
    _s := str.replace_all(_s, "5",  "0")
    _s := str.replace_all(_s, "1",  "0")

// Collect inputs

riskToRewardRatio = input.int(1, minval=1, title="Risk:Reward")
stopLossActivationFactor = input.float (0.25, title="S.L. Activation in terms of R/R factor")

atrLength = input.int(30, minval=1, title="ATR Length")
atrStopMultiplier = input.float(1.0, minval=0.1, title="ATR x ?")

tenkanSenPeriod = input.int(9, minval=1, title="Tenkan Sen Length")
kijunSenPeriod = input.int(26, minval=1, title="Kijun Sen Length")
senkouSpanBPeriod = input.int(52, minval=1, title="Leading Span B Length")
displacement = input.int(26, minval=1, title="Displacement")
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))

tenkanSen = donchian(tenkanSenPeriod)
kijunSen = donchian(kijunSenPeriod)
senkouSpanA = math.avg(tenkanSen, kijunSen)
senkouSpanB = donchian(senkouSpanBPeriod)

// Calculate stop-loss using ATR
r = ta.atr(atrLength) * atrStopMultiplier
entryPrice = close
longEntryStop = kijunSen - r
shortEntryStop = kijunSen + r

// Assess for high probability setup on the trading timeframe

// 1. Where is price w.r.t Kumo? [above | below | within]

isCurrentKumoGreen = senkouSpanA[displacement-1] > senkouSpanB[displacement-1]
isCurrentKumoRed = senkouSpanB[displacement-1] > senkouSpanA[displacement-1]

isPriceAboveKumo = isCurrentKumoGreen ? (close > senkouSpanA[displacement-1]) : (isCurrentKumoRed ? (close > senkouSpanB[displacement-1]) : false)
isPriceBelowKumo = isCurrentKumoGreen ? (close < senkouSpanB[displacement-1]) : (isCurrentKumoRed ? (close < senkouSpanA[displacement-1]) : false)

//f_print("Current Kumo: " + (isCurrentKumoGreen ? "Green": (isCurrentKumoRed ? "Red" : " twist ")) + ", senkouSpanA: " + str.tostring(senkouSpanA[displacement-1]) + ", senkouSpanB: " + str.tostring(senkouSpanB[displacement-1]))
//f_print("Current Kumo: " + (isCurrentKumoGreen ? "Green": (isCurrentKumoRed ? "Red" : " twist ")) + ", Price is " + (isPriceAboveKumo ? "Above" : (isPriceBelowKumo ? "Below" : "Within")))

// 2. Where is price w.r.t nearby flat Kumo-Shadow? [far | near]

// 3. Where is price w.r.t Tenkan? [above | below]
isPriceAboveTenkanSen = close > tenkanSen
isPriceBelowTenkanSen = close < tenkanSen

// 4. Where is Tenkan w.r.t Kijun? [above | below]
isTenkanSenAboveKijunSen = tenkanSen > kijunSen
isTenkanSenBelowKijunSen = tenkanSen < kijunSen

// 5. Where is TK Cross w.r.t Kumo? [above | below | within] <--- This is not a filter. Ignore!
var wasLastTkCrossBullish = false
var wasLastTkCrossBearish = false
var wasLastTkCrossAboveKumo = false
var wasLastTkCrossBelowKumo = false

if (tenkanSen[1] <= kijunSen[1] and tenkanSen > kijunSen)
    wasLastTkCrossBullish := true
    wasLastTkCrossBearish := false

if (tenkanSen[1] >= kijunSen[1] and tenkanSen < kijunSen)
    wasLastTkCrossBullish := false
    wasLastTkCrossBearish := true

if (wasLastTkCrossBullish or wasLastTkCrossBearish)
    wasLastTkCrossAboveKumo := isCurrentKumoGreen ? (kijunSen > senkouSpanA[displacement-1]) : (isCurrentKumoRed ? (kijunSen > senkouSpanB[displacement-1]) : false)
    wasLastTkCrossBelowKumo := isCurrentKumoGreen ? (kijunSen < senkouSpanB[displacement-1]) : (isCurrentKumoRed ? (kijunSen < senkouSpanA[displacement-1]) : false)

// 6. How is future Kumo? [bullish | bearish | unknown (twist)]
isFutureKumoGreen = senkouSpanA > senkouSpanB
isFutureKumoRed = senkouSpanB > senkouSpanA

// 7. Where is Chikou w.r.t Price? [above | below | within]
isChikouSpanAbovePrice = close > high[displacement-1]
isChikouSpanBelowPrice = close < low[displacement-1]

//f_print(str.tostring(displacement-1) + " bar price" + str.tostring(close[displacement-1]))

// 8. Where is Chikou w.r.t Kumo? [above | below | within]

isChikouKumoGreen = senkouSpanA[2*displacement-1] > senkouSpanB[2*displacement-1]
isChikouKumoRed = senkouSpanB[2*displacement-1] > senkouSpanA[2*displacement-1]

isChikouSpanAboveKumo = isChikouKumoGreen ? (close > senkouSpanA[2*displacement-1]) : (isChikouKumoRed ? (close > senkouSpanB[2*displacement-1]) : false)
isChikouSpanBelowKumo = isChikouKumoGreen ? (close < senkouSpanB[2*displacement-1]) : (isChikouKumoRed ? (close < senkouSpanA[2*displacement-1]) : false)
//f_print("Chikou Kumo: " + (isChikouKumoGreen ? "Green": (isChikouKumoRed ? "Red" : " twist ")) + ", Chikou is " + (isChikouSpanAboveKumo ? "Above" : (isChikouSpanBelowKumo ? "Below" : "Within")))

// 9. Where is Chikou w.r.t a flat Senkou-Span-B? [above | below]

// 10. Is Chikou free from congestion ahead? [yes | no]
congestionProximity = input.int(10, minval=1, title="Chikou's required congestion free bar range:")
congestionTolerance = input.float(0, minval=0.0, title="Congestion Tolerance")

highestForChikou = (1-congestionTolerance/100) * ta.highest(high[displacement-congestionProximity], congestionProximity)
lowestForChikou = (1-congestionTolerance/100) * ta.lowest(low[displacement-congestionProximity], congestionProximity)

isChikouSpanFree = isChikouSpanAbovePrice ? (close > highestForChikou) : isChikouSpanBelowPrice ? (close < lowestForChikou) : false
//f_print("isChikouSpanFree: " + str.tostring(isChikouSpanFree) + " in the next " + str.tostring(congestionProximity) + " bars, highest: " + str.tostring(highestForChikou) + ", lowest: " + str.tostring(lowestForChikou) + "\n")


// Declare constants to access global variables
IDX_PriceLevelToBeginTrailingStopLoss = 0
IDX_ShouldExitOnStopLoss = 1
IDX_UseKijunAsStopLoss = 2

f_reset() =>
    f_set(IDX_PriceLevelToBeginTrailingStopLoss, -1)
    f_set(IDX_ShouldExitOnStopLoss, NO)
    f_set(IDX_UseKijunAsStopLoss, NO)
    
// Check confluence

hasBullishConfluence = isPriceAboveKumo and isPriceAboveTenkanSen and isTenkanSenAboveKijunSen and isFutureKumoGreen and isChikouSpanAbovePrice and isChikouSpanFree
hasBearishConfluence = isPriceBelowKumo and isPriceBelowTenkanSen and isTenkanSenBelowKijunSen and isFutureKumoRed and isChikouSpanBelowPrice and isChikouSpanFree

ssbProximityToChikou = -1
lowestSSB = ta.lowest(senkouSpanB[2*displacement - 1 - congestionProximity], congestionProximity)
highestSSB = ta.highest(senkouSpanB[2*displacement - 1 - congestionProximity], congestionProximity)

if (hasBullishConfluence and isChikouSpanBelowKumo)
    ssbProximityToChikou = (lowestSSB - close)*100/close
    //f_print(">> overhead resistance at " + str.tostring(ssbProximityToChikou))

if (hasBearishConfluence and isChikouSpanAboveKumo)
    ssbProximityToChikou = (close - lowestSSB)*100/close
    //f_print(">> underlying support at " + str.tostring(ssbProximityToChikou) + "\n")

// Asssess exit scenarios

// 1. Where is price w.r.t Kijun-Sen?

var inLongTrade = false
var inShortTrade = false

isPriceAboveKijunSen = false
isPriceBelowKijunSen = false
if inLongTrade // for exiting in a long position 
    isPriceBelowKijunSen := low < kijunSen
    isPriceAboveKijunSen := low > kijunSen
else if inShortTrade // for exiting in a short position
    isPriceBelowKijunSen := high < kijunSen
    isPriceAboveKijunSen := high > kijunSen
else // for confluence to enter position
    isPriceAboveKijunSen := close > kijunSen
    isPriceBelowKijunSen := close < kijunSen

//f_print("isPriceAboveKijunSen? = " + str.tostring(isPriceAboveKijunSen) + ", isPriceBelowKijunSen? = " + str.tostring(isPriceBelowKijunSen) + ", kijunSen: " + str.tostring(kijunSen) + ", high: " + str.tostring(high) + ", low: " + str.tostring(low) + " check? " +  str.tostring(low < kijunSen))

shouldScaleOut = false


//#############################################################
//##     Manage LONG Position                                ##
//#############################################################

var canPrepareForLong = false
var shouldSellOnTenkan = false
var shouldSellOnKijun = false
var shouldSellOnLimitOrder = false
var didSellOnLimitOrder = false

var longEntryPrice = 0.0
var longStopLoss = 0.0
var tenkanSellPrice1 = 0.0
var tenkanSellPrice2 = 0.0
var tenkanSellPrice3 = 0.0
var tenkanSellPrice4 = 0.0
var tenkanSellPrice5 = 0.0
var kijunSellPrice = 0.0
var sellLimitOrder = 0.0

if not inLongTrade
    shouldSellOnKijun := false
    shouldScaleOut := true
    shouldSellOnTenkan := false
    shouldSellOnLimitOrder := false
    didSellOnLimitOrder := false

    longEntryPrice := 0.0
    longStopLoss := 0.0
    tenkanSellPrice1 := 0.0
    tenkanSellPrice2 := 0.0
    tenkanSellPrice3 := 0.0
    tenkanSellPrice4 := 0.0
    tenkanSellPrice5 := 0.0
    kijunSellPrice := 0.0
    sellLimitOrder := 0.0

if (inLongTrade and high > f_get(IDX_PriceLevelToBeginTrailingStopLoss))
    f_set(IDX_UseKijunAsStopLoss, YES)

if (inLongTrade and low <= longStopLoss)
    f_set(IDX_ShouldExitOnStopLoss, YES)

if (inLongTrade and isPriceBelowKijunSen and f_true(IDX_UseKijunAsStopLoss))
    shouldSellOnKijun := true
    shouldScaleOut := true
    kijunSellPrice := kijunSen

if (inLongTrade and hasBearishConfluence)
    inLongTrade := false
    
//f_print("[L1] inLongTrade: " + str.tostring(inLongTrade) + ", exit? = " + str.tostring(shouldSellOnKijun) + ", bullishConf? = " + str.tostring(hasBullishConfluence) + "\n")

canPrepareForLong := not inLongTrade and hasBullishConfluence
if canPrepareForLong
    inLongTrade := true
    shouldSellOnKijun := false
    longEntryPrice := close
    longStopLoss := longEntryStop
    sellLimitOrder := longEntryPrice + (longEntryPrice - longEntryStop) * riskToRewardRatio
    array.set(context, IDX_PriceLevelToBeginTrailingStopLoss, longEntryPrice + (longEntryPrice - longEntryStop) * stopLossActivationFactor)
    line.new(bar_index, f_get(IDX_PriceLevelToBeginTrailingStopLoss), bar_index+10, f_get(IDX_PriceLevelToBeginTrailingStopLoss), width=1, color=color.gray, style=line.style_dotted)
    //line.new(bar_index+ta.highestbars(high, tenkanSenPeriod), ta.highest(high, tenkanSenPeriod), bar_index+3, ta.highest(high, tenkanSenPeriod), width=1, color=color.green, style=line.style_dotted)
    line.new(bar_index, longStopLoss, bar_index+3, longStopLoss, width=1, color=color.green, style=line.style_dotted)

if (inLongTrade and not shouldSellOnKijun and close < tenkanSen and close[1] >= tenkanSen[1])
    shouldSellOnTenkan := true
    if (tenkanSellPrice1 == 0.0)
        tenkanSellPrice1 := close
    else if (tenkanSellPrice2 == 0.0)
        tenkanSellPrice2 := close
    else if (tenkanSellPrice3 == 0.0)
        tenkanSellPrice3 := close
    else if (tenkanSellPrice4 == 0.0)
        tenkanSellPrice4 := close
    else if (tenkanSellPrice5 == 0.0)
        tenkanSellPrice5 := close
else
    shouldSellOnTenkan := false
    
if (inLongTrade and not didSellOnLimitOrder and close >= sellLimitOrder)
    shouldSellOnLimitOrder := true

//f_print("[L2] inLongTrade: " + str.tostring(inLongTrade) + ", exit? = " + str.tostring(shouldSellOnKijun) + ", canPrepareForLong: " + str.tostring(canPrepareForLong) + "\n\n")

// Plot LONG signals based on confluence
plotshape(canPrepareForLong, title= "Long Entry", location=location.belowbar, color=color.green, transp=0, style=shape.triangleup, text="", size=size.small)
if canPrepareForLong
    canPrepareForLong := false // reset flag

plotshape(shouldSellOnTenkan, title= "Tenkan Long Exit", location=location.abovebar, color=color.aqua, transp=0, style=shape.diamond, text="", size=size.tiny)

plotshape(shouldSellOnKijun, title= "Kijun Long Exit", location=location.abovebar, color=color.green, transp=0, style=shape.xcross, text="", size=size.small)

plotshape(inLongTrade and f_true(IDX_ShouldExitOnStopLoss), title= "Stop Loss Long Exit", location=location.belowbar, color=color.rgb(182, 209, 186), transp=0, style=shape.xcross, text="", size=size.small)

plotshape(shouldSellOnLimitOrder, title= "Fixed Long Exit", location=location.abovebar, color=color.aqua, transp=0, style=shape.square, text="", size=size.tiny)
if shouldSellOnLimitOrder
    didSellOnLimitOrder := true
    shouldSellOnLimitOrder := false

// Draw labels to enter or trail a stop-loss order based on confluence

if inLongTrade
    var labelLong = label.new(bar_index, kijunSen,  text = "Trail S.L.", style = label.style_label_lower_left, color = color.green)
    label.set_xy(labelLong, bar_index+1, kijunSen)
    label.set_tooltip(labelLong, "Stop loss @ "  + str.tostring(kijunSen, str.tostring(f_tickFormat())))

if (inLongTrade and (shouldSellOnKijun or f_true(IDX_ShouldExitOnStopLoss)))
    inLongTrade := false
    f_reset()


//#############################################################
//##     Manage SHORT Position                               ##
//#############################################################

var canPrepareForShort = false
var shouldBuyOnTenkan = false
var shouldBuyOnKijun = false
var shouldBuyOnLimitOrder = false
var didBuyOnLimitOrder = false

var shortEntryPrice = 0.0
var shortStopLoss = 0.0
var tenkanBuyPrice1 = 0.0
var tenkanBuyPrice2 = 0.0
var tenkanBuyPrice3 = 0.0
var tenkanBuyPrice4 = 0.0
var tenkanBuyPrice5 = 0.0
var kijunBuyPrice = 0.0
var buyLimitOrder = 0.0

if not inShortTrade
    shouldBuyOnKijun := false
    shouldScaleOut := true
    shouldBuyOnLimitOrder := false
    didBuyOnLimitOrder := false
    shortEntryPrice := 0.0
    shortStopLoss := 0.0
    tenkanBuyPrice1 := 0.0
    tenkanBuyPrice2 := 0.0
    tenkanBuyPrice3 := 0.0
    tenkanBuyPrice4 := 0.0
    tenkanBuyPrice5 := 0.0
    kijunBuyPrice := 0.0
    buyLimitOrder := 0.0

if (inShortTrade and low < f_get(IDX_PriceLevelToBeginTrailingStopLoss))
    f_set(IDX_UseKijunAsStopLoss, YES)

if (inShortTrade and high >= shortStopLoss)
    f_set(IDX_ShouldExitOnStopLoss, YES)

//f_print("low: " + str.tostring(low) + ", shortSL: " + str.tostring(shortStopLoss) +", finalSL: " + f_getString(IDX_PriceLevelToBeginTrailingStopLoss) + ", useKijonAsSL: " + f_getString(IDX_UseKijunAsStopLoss)+ ", shouldExitOnSL: " + f_getString(IDX_ShouldExitOnStopLoss))

if (inShortTrade and isPriceAboveKijunSen and f_true(IDX_UseKijunAsStopLoss))
    shouldBuyOnKijun := true
    shouldScaleOut := true
    kijunBuyPrice := kijunSen

if (inShortTrade and hasBullishConfluence)
    inShortTrade := false

//f_print("[S1] inShortTrade: " + str.tostring(inShortTrade) + ", exit? = " + str.tostring(shouldBuyOnKijun) + ", bearishConf? = " + str.tostring(hasBearishConfluence) + ", isPriceAboveKijunsen? = " + str.tostring(isPriceAboveKijunSen) + "\n\n\n")

canPrepareForShort :=  not inShortTrade and hasBearishConfluence
if canPrepareForShort
    inShortTrade := true
    shouldBuyOnKijun := false
    shortEntryPrice := close
    shortStopLoss := shortEntryStop
    buyLimitOrder := shortEntryPrice - (shortEntryStop - shortEntryPrice) * riskToRewardRatio
    array.set(context, IDX_PriceLevelToBeginTrailingStopLoss, shortEntryPrice + (shortEntryPrice - shortStopLoss) * stopLossActivationFactor)
    line.new(bar_index, f_get(IDX_PriceLevelToBeginTrailingStopLoss), bar_index+10, f_get(IDX_PriceLevelToBeginTrailingStopLoss), width=1, color=color.gray, style=line.style_dotted)
    //line.new(bar_index+ta.lowestbars(low, tenkanSenPeriod)-2, ta.lowest(low, tenkanSenPeriod), bar_index+3, ta.lowest(low, tenkanSenPeriod), width=1, color=color.red, style=line.style_dotted)
    line.new(bar_index, shortStopLoss, bar_index+3, shortStopLoss, width=1, color=color.red, style=line.style_dotted)

if (inShortTrade and not shouldBuyOnKijun and close > tenkanSen and close[1] <= tenkanSen[1])
    shouldBuyOnTenkan := true
    if (tenkanBuyPrice1 == 0.0)
        tenkanBuyPrice1 := close
    else if (tenkanBuyPrice2 == 0.0)
        tenkanBuyPrice2 := close
    else if (tenkanBuyPrice3 == 0.0)
        tenkanBuyPrice3 := close
    else if (tenkanBuyPrice4 == 0.0)
        tenkanBuyPrice4 := close
    else if (tenkanBuyPrice5 == 0.0)
        tenkanBuyPrice5 := close
else
    shouldBuyOnTenkan := false
    
if (inShortTrade and not didBuyOnLimitOrder and close <= buyLimitOrder)
    shouldBuyOnLimitOrder := true

//f_print("[S2] inShortTrade: " + str.tostring(inShortTrade) + ", exit? = " + str.tostring(shouldBuyOnKijun) + ", canPrepareForShort: " + str.tostring(canPrepareForShort) + ", isPriceAboveKijunsen? = " + str.tostring(isPriceAboveKijunSen) + "\n\n\n\n")

// Plot SHORT signals based on confluence
plotshape(canPrepareForShort,  title= "Short Entry", location=location.abovebar, color=color.red, transp=0, style=shape.triangledown, text="", size=size.small)
if canPrepareForShort
    canPrepareForShort := false // reset flag

plotshape(shouldBuyOnTenkan, title= "Tenkan Short Exit", location=location.belowbar, color=color.orange, transp=0, style=shape.diamond, text="", size=size.tiny)

plotshape(shouldBuyOnKijun, title= "Kijun Short Exit", location=location.belowbar, color=color.red, transp=0, style=shape.xcross, text="", size=size.small)

plotshape(inShortTrade and f_true(IDX_ShouldExitOnStopLoss), title= "Stop Loss Short Exit", location=location.abovebar, color=color.rgb(255, 153, 153), transp=0, style=shape.xcross, text="", size=size.small)

plotshape(shouldBuyOnLimitOrder, title= "Fixed Short Exit", location=location.belowbar, color=color.orange, transp=0, style=shape.square, text="", size=size.tiny)

if shouldBuyOnLimitOrder
    didBuyOnLimitOrder := true
    shouldBuyOnLimitOrder := false

// Draw labels to enter or trail a stop-loss order based on confluence
if inShortTrade
    var labelShort = label.new(bar_index, kijunSen, text = "Trail S.L.", style = label.style_label_upper_left, color = color.red)
    label.set_xy(labelShort, bar_index+1, kijunSen)
    label.set_tooltip(labelShort, "Stop loss @ " + str.tostring(kijunSen, str.tostring(f_tickFormat())))

if (inShortTrade and (shouldBuyOnKijun or f_true(IDX_ShouldExitOnStopLoss)))
    inShortTrade := false
    f_reset()



//#############################################################
//##     Profit & Loss                                       ##
//#############################################################

float accountSize = input.float(1000, title="Account Size")
float maxRisk = input.float(25, title="Max risk per position") / 100
float exitPercent = input.float(25, title="Scale out percent") / 100
float maxRiskPerPosition = accountSize * maxRisk
float qty = 0.0, tradeSize = 0.0, pnl = 0.0, remainingUnitsAllocation = 0.0, remainingPercentAllocation = 1.0

// Temporary variables for debugging
float t1 = 0.0, t2 = 0.0, t3 = 0.0, t4 = 0.0, t5 = 0.0, k = 0.0, lo = 0.0, dt1 = 0.0, dt2 = 0.0, dt3 = 0.0, dt4 = 0.0, dt5 = 0.0, dk = 0.0, dlo = 0.0
if not inLongTrade
    t1 := 0, t2 := 0, t3 := 0, t4 := 0, t5 := 0, k := 0, lo := 0, dt1 := 0, dt2 := 0, dt3 := 0, dt4 := 0, dt5 := 0, dk := 0, dlo := 0

if inLongTrade
    qty := maxRiskPerPosition / (longEntryPrice - longStopLoss)
    tradeSize := qty * longEntryPrice
    remainingUnitsAllocation = qty
    
    if sellLimitOrder > 0 and didSellOnLimitOrder and remainingPercentAllocation > 0
        dlo := (sellLimitOrder - longEntryPrice) 
        lo := dlo * exitPercent * qty
        pnl := pnl + lo
        remainingUnitsAllocation := remainingUnitsAllocation - (qty * exitPercent)
        remainingPercentAllocation := remainingPercentAllocation - exitPercent
    if tenkanSellPrice1 > 0 and remainingPercentAllocation > 0
        dt1 := (tenkanSellPrice1 - longEntryPrice)
        t1 := dt1 * exitPercent * qty
        pnl := pnl + t1
        remainingUnitsAllocation = remainingUnitsAllocation - (qty * exitPercent)
        remainingPercentAllocation := remainingPercentAllocation - exitPercent
    if tenkanSellPrice2 > 0 and remainingPercentAllocation > 0
        dt2 := (tenkanSellPrice2 - longEntryPrice)
        t2 := dt2 * exitPercent * qty
        pnl := pnl + t2
        remainingUnitsAllocation := remainingUnitsAllocation - (qty * exitPercent)
        remainingPercentAllocation := remainingPercentAllocation - exitPercent
    if tenkanSellPrice3 > 0 and remainingPercentAllocation > 0
        dt3 := (tenkanSellPrice3 - longEntryPrice)
        t3 := dt3 * exitPercent * qty
        pnl := pnl + t3
        remainingUnitsAllocation := remainingUnitsAllocation - (qty * exitPercent)
        remainingPercentAllocation := remainingPercentAllocation - exitPercent
    if tenkanSellPrice4 > 0 and remainingPercentAllocation > 0
        dt4 := (tenkanSellPrice4 - longEntryPrice)
        t4 := dt4 * exitPercent * qty
        pnl := pnl + t4
        remainingUnitsAllocation := remainingUnitsAllocation - (qty * exitPercent)
        remainingPercentAllocation := remainingPercentAllocation - exitPercent
    if tenkanSellPrice5 > 0 and remainingPercentAllocation > 0
        dt5 := (tenkanSellPrice5 - longEntryPrice)
        t5 := dt5 * exitPercent * qty
        pnl := pnl + t5
        remainingUnitsAllocation := remainingUnitsAllocation - (qty * exitPercent)
        remainingPercentAllocation := remainingPercentAllocation - exitPercent
    if kijunSellPrice > 0 and remainingPercentAllocation > 0
        if kijunSellPrice < longStopLoss
            k := (longStopLoss - longEntryPrice) * remainingUnitsAllocation
            pnl := pnl + k
        else
            pnl := pnl + (kijunSellPrice - longEntryPrice) * remainingUnitsAllocation
    

//#############################################################
//##     Information Display Panels                          ##
//#############################################################

// Display confluence information
showPnl = input.bool(false, title="Profit & Loss")
var table pnlTable = table.new(position.bottom_center, 2, 1, bgcolor = color.rgb(0, 0, 0, 30), frame_color = color.black)
if (barstate.islast and showPnl)
    table.cell(pnlTable, 0, 0, "$" + str.tostring(pnl, str.tostring(f_tickFormat())), text_color = color.silver, text_halign = text.align_center)
    table.cell(pnlTable, 1, 0, (tradeSize > 0 ? str.tostring(100*pnl/tradeSize, str.tostring(f_tickFormat())) + "%" : ""), text_color = color.white, text_halign = text.align_center)


// Display trade information
showTradePlan = input.bool(false, title="Trade Plan")
var table tradeTable = table.new(position.top_right, 12, 5, bgcolor = color.rgb(0, 0, 0, 30), frame_width = 2, frame_color = color.black)
if (barstate.islast and showTradePlan)
    table.cell(tradeTable, 1, 0, "Entry", text_color = color.white)
    table.cell(tradeTable, 2, 0, "S.L.", text_color = color.white)
    table.cell(tradeTable, 3, 0, "T. Exit 1", text_color = color.white)
    table.cell(tradeTable, 4, 0, "T. Exit 2", text_color = color.white)
    table.cell(tradeTable, 5, 0, "T. Exit 3", text_color = color.white)
    table.cell(tradeTable, 6, 0, "T. Exit 4", text_color = color.white)
    table.cell(tradeTable, 7, 0, "T. Exit 5", text_color = color.white)
    table.cell(tradeTable, 8, 0, "K. Exit", text_color = color.white)
    table.cell(tradeTable, 9, 0, "Limit Order", text_color = color.white)
    table.cell(tradeTable, 10, 0, "Qty", text_color = color.white)
    table.cell(tradeTable, 11, 0, "ATR", text_color = color.white)
    table.cell(tradeTable, 0, 1, "Long", text_color = color.white)
    table.cell(tradeTable, 1, 1, str.tostring(longEntryPrice, str.tostring(f_tickFormat())), text_color = color.green)
    table.cell(tradeTable, 2, 1, str.tostring(longStopLoss, str.tostring(f_tickFormat())), text_color = color.red)
    table.cell(tradeTable, 3, 1, str.tostring(tenkanSellPrice1, str.tostring(f_tickFormat())), text_color = color.aqua)
    table.cell(tradeTable, 4, 1, str.tostring(tenkanSellPrice2, str.tostring(f_tickFormat())), text_color = color.aqua)
    table.cell(tradeTable, 5, 1, str.tostring(tenkanSellPrice3, str.tostring(f_tickFormat())), text_color = color.aqua)
    table.cell(tradeTable, 6, 1, str.tostring(tenkanSellPrice4, str.tostring(f_tickFormat())), text_color = color.aqua)
    table.cell(tradeTable, 7, 1, str.tostring(tenkanSellPrice5, str.tostring(f_tickFormat())), text_color = color.aqua)
    table.cell(tradeTable, 8, 1, str.tostring(kijunSellPrice, str.tostring(f_tickFormat())), text_color = color.aqua)
    table.cell(tradeTable, 9, 1, (didSellOnLimitOrder ? str.tostring(sellLimitOrder, str.tostring(f_tickFormat())) : "0.0"), text_color = color.aqua)
    table.cell(tradeTable, 10, 1, str.tostring(qty), text_color = color.gray)
    table.cell(tradeTable, 11, 1, str.tostring(r, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 0, 2, "Short", text_color = color.white)
    table.cell(tradeTable, 1, 2, str.tostring(shortEntryPrice, str.tostring(f_tickFormat())), text_color = color.red)
    table.cell(tradeTable, 2, 2, str.tostring(shortStopLoss, str.tostring(f_tickFormat())), text_color = color.green)
    table.cell(tradeTable, 3, 2, str.tostring(tenkanBuyPrice1, str.tostring(f_tickFormat())), text_color = color.orange)
    table.cell(tradeTable, 4, 2, str.tostring(tenkanBuyPrice2, str.tostring(f_tickFormat())), text_color = color.orange)
    table.cell(tradeTable, 5, 2, str.tostring(tenkanBuyPrice3, str.tostring(f_tickFormat())), text_color = color.orange)
    table.cell(tradeTable, 6, 2, str.tostring(tenkanBuyPrice4, str.tostring(f_tickFormat())), text_color = color.orange)
    table.cell(tradeTable, 7, 2, str.tostring(tenkanBuyPrice5, str.tostring(f_tickFormat())), text_color = color.orange)
    table.cell(tradeTable, 8, 2, str.tostring(kijunBuyPrice, str.tostring(f_tickFormat())), text_color = color.orange)
    table.cell(tradeTable, 9, 2, (didBuyOnLimitOrder ? str.tostring(buyLimitOrder, str.tostring(f_tickFormat())) : "0.0"), text_color = color.orange)
    table.cell(tradeTable, 10, 2, str.tostring(qty), text_color = color.gray)
    table.cell(tradeTable, 11, 2, str.tostring(r, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 0, 3, "P&L", text_color = color.white)
    table.cell(tradeTable, 1, 3, str.tostring(pnl, str.tostring(f_tickFormat())), text_color = color.white)
    table.cell(tradeTable, 2, 3, "⟸", text_color = color.white)
    table.cell(tradeTable, 3, 3, str.tostring(t1, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 4, 3, str.tostring(t2, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 5, 3, str.tostring(t3, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 6, 3, str.tostring(t4, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 7, 3, str.tostring(t5, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 8, 3, str.tostring(k, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 9, 3, str.tostring(lo, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 10, 3, str.tostring(remainingUnitsAllocation, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 2, 4, "+/-", text_color = color.white)
    table.cell(tradeTable, 3, 4, str.tostring(dt1, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 4, 4, str.tostring(dt2, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 5, 4, str.tostring(dt3, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 6, 4, str.tostring(dt4, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 7, 4, str.tostring(dt5, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 8, 4, str.tostring(dk, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 9, 4, str.tostring(dlo, str.tostring(f_tickFormat())), text_color = color.gray)
    table.cell(tradeTable, 10, 4, "$" + str.tostring(tradeSize, str.tostring(f_tickFormat())), text_color = color.blue)
    table.cell(tradeTable, 11, 4, str.tostring(exitPercent*100) + "%", text_color = color.gray)


// Display debug information
showL1DebugInfo = input.bool(false, title="Debug Info (Level 1)")
var table debugTable = table.new(position.bottom_left, 7, 3, bgcolor = color.silver, frame_width = 2, frame_color = color.gray)
if (barstate.islast and showL1DebugInfo)
    table.cell(debugTable, 1, 0, "Is Active?", text_color = color.black)
    table.cell(debugTable, 2, 0, "Should Scale Out?", text_color = color.black)
    table.cell(debugTable, 3, 0, "Need Exit?", text_color = color.black)
    table.cell(debugTable, 4, 0, "Should Enter?", text_color = color.black)
    table.cell(debugTable, 5, 0, "-", text_color = color.black)
    table.cell(debugTable, 6, 0, "Sentiment", text_color = color.black)
    table.cell(debugTable, 0, 1, "Long", text_color = color.black)
    table.cell(debugTable, 1, 1, str.tostring(inLongTrade), text_color = color.navy)
    table.cell(debugTable, 2, 1, str.tostring(shouldScaleOut), text_color = color.navy)
    table.cell(debugTable, 3, 1, str.tostring(shouldSellOnKijun), text_color = color.navy)
    table.cell(debugTable, 4, 1, str.tostring(canPrepareForLong), text_color = color.navy)
    table.cell(debugTable, 5, 1, "-", text_color = color.navy)
    table.cell(debugTable, 6, 1, str.tostring(hasBullishConfluence? "Bullish": "-"), text_color = color.navy)
    table.cell(debugTable, 0, 2, "Short", text_color = color.black)
    table.cell(debugTable, 1, 2, str.tostring(inShortTrade), text_color = color.maroon)
    table.cell(debugTable, 2, 2, str.tostring(shouldScaleOut), text_color = color.maroon)
    table.cell(debugTable, 3, 2, str.tostring(shouldBuyOnKijun), text_color = color.maroon)
    table.cell(debugTable, 4, 2, str.tostring(canPrepareForShort), text_color = color.maroon)
    table.cell(debugTable, 5, 2, "-", text_color = color.maroon)
    table.cell(debugTable, 6, 2, str.tostring(hasBearishConfluence? "Bearish": "-"), text_color = color.rgb(255, 153, 153))
    

// Display confluence information
showConfluenceInfo = input.bool(false, title="Confluence Info")
var table confluenceTable = table.new(position.bottom_right, 3, 10, bgcolor = color.rgb(0, 0, 0, 30), frame_width = 2, frame_color = color.black)
if (barstate.islast and showConfluenceInfo)
    table.cell(confluenceTable, 0, 0, "1. Price " + (isPriceAboveKumo ? "above" : (isPriceBelowKumo ? "below" : "consolidating within")) + " kumo.", text_color = (isPriceAboveKumo ? color.green : (isPriceBelowKumo ? color.red : color.white)), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 1, "2. Is price heading into kumo shadows?", text_color = color.yellow, text_halign = text.align_left)
    table.cell(confluenceTable, 0, 2, "3. Price " + (isPriceAboveTenkanSen ? "above" : (isPriceBelowTenkanSen ? "below" : "overlapping")) + " tenkan.", text_color = isPriceAboveTenkanSen ? color.green : (isPriceBelowTenkanSen ? color.red : color.white), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 3, "4. Tenkan " + (isTenkanSenAboveKijunSen ? "above" : (isTenkanSenBelowKijunSen ? "below" : "overlapping")) + " kijun.", text_color = (isTenkanSenAboveKijunSen ? color.green : (isTenkanSenBelowKijunSen ? color.red : color.white)), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 4, "5. " + (wasLastTkCrossBullish? "Bullish " : (wasLastTkCrossBearish? "Bearish ": "")) + "TK Cross " + (wasLastTkCrossAboveKumo ? "above" : (wasLastTkCrossBelowKumo ? "below" : "within")) + " kumo.", text_color = (wasLastTkCrossAboveKumo ? (wasLastTkCrossBullish ? color.green : (wasLastTkCrossBearish ? color.rgb(255, 153, 153) : color.white)) : (wasLastTkCrossBelowKumo ? ( wasLastTkCrossBullish ? color.rgb(182, 209, 186) : (wasLastTkCrossBearish ? color.red : color.white)) : color.gray ) ) , text_halign = text.align_left)
    table.cell(confluenceTable, 0, 5, "6. " + (isFutureKumoGreen ? "Bullish" : (isFutureKumoRed ? "Bearish" : "Twisted")) + " future kumo.", text_color = (isFutureKumoGreen ? color.green : (isFutureKumoRed ? color.red : color.white)), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 6, "7. Chikou " + (isChikouSpanAbovePrice ? "above" : (isChikouSpanBelowPrice ? "below" : "hitting")) + " price.", text_color = (isChikouSpanAbovePrice ? color.green : (isChikouSpanBelowPrice ? color.red : color.white)), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 7, "8. Chikou " + (isChikouSpanAboveKumo ? "above" : (isChikouSpanBelowKumo ? "below" : "within")) + " kumo.", text_color = (isChikouSpanAboveKumo ? color.rgb(182, 209, 186) : (isChikouSpanBelowKumo ? color.rgb(255, 153, 153) : color.gray)), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 8, "9. SSB " + (ssbProximityToChikou < 0 ? " may not block Chikou" : " might block Chikou at " + str.tostring(ssbProximityToChikou) + "%") + " for " + (isChikouSpanAboveKumo ? "long" : "short"  )+ " trade.", text_color = ( ssbProximityToChikou < 0 and hasBullishConfluence ? color.green : ( ssbProximityToChikou < 0 and hasBearishConfluence ? color.red : color.gray)), text_halign = text.align_left)
    table.cell(confluenceTable, 0, 9, "10. Chikou " + (isChikouSpanFree ? "clear from congestion." : " heading into " + str.tostring(congestionProximity) + " candles!"), text_color = (isChikouSpanFree ? (hasBullishConfluence ? color.green : (hasBearishConfluence ? color.red : color.gray)) : color.white), text_halign = text.align_left)
