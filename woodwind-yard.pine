//  ██╗    ██╗ ██████╗  ██████╗ ██████╗ ██╗    ██╗██╗███╗   ██╗██████╗     ██╗   ██╗ █████╗ ██████╗ ██████╗ 
//  ██║    ██║██╔═══██╗██╔═══██╗██╔══██╗██║    ██║██║████╗  ██║██╔══██╗    ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗
//  ██║ █╗ ██║██║   ██║██║   ██║██║  ██║██║ █╗ ██║██║██╔██╗ ██║██║  ██║     ╚████╔╝ ███████║██████╔╝██║  ██║
//  ██║███╗██║██║   ██║██║   ██║██║  ██║██║███╗██║██║██║╚██╗██║██║  ██║      ╚██╔╝  ██╔══██║██╔══██╗██║  ██║
//  ╚███╔███╔╝╚██████╔╝╚██████╔╝██████╔╝╚███╔███╔╝██║██║ ╚████║██████╔╝       ██║   ██║  ██║██║  ██║██████╔╝
//   ╚══╝╚══╝  ╚═════╝  ╚═════╝ ╚═════╝  ╚══╝╚══╝ ╚═╝╚═╝  ╚═══╝╚═════╝        ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ 
//                                                                                                        
// © 2021
// @ govindthange

//
// @version=5
// @description provides ancillary functions to support Woodwind Playbook.
//
library("WoodwindYard", overlay=true)


//
// @function determines the highest-high and the lowest-low value for the specified interval.
// @param index, used to pick the last data point for using higher timeframe data in lower timeframe.
// @param period int, the time interval.
// @returns float, the highest-high and lowest-low value.
//
export getHighestHighAndLowestLow(int index, int period) => math.avg(ta.lowest(low[index], period), ta.highest(high[index], period))

//
// @function determines the highest-high and the lowest-low value for the specified interval.
// @param shortTermPeriod int, the short-term equilibrium point period.
// @param midTermPeriod int, the intermediate-term equilibrium point period.
// @returns float, the highest & lowest short-term & mid-term bar and corresponding price.
//
export getHighestHighAndLowestLowSet(int shortTermPeriod, int midTermPeriod, bool includeCurrentBar) =>
    int barIndex = includeCurrentBar ? 0 : 1
    int highestShortTermBar = ta.highestbars(high[barIndex], shortTermPeriod)
    float highestShortTermValue = ta.highest(high[barIndex], shortTermPeriod)
    int lowestShortTermBar = ta.lowestbars(low[barIndex], shortTermPeriod)
    float lowestShortTermValue = ta.lowest(low[barIndex], shortTermPeriod)
    int highestMidTermBar = ta.highestbars(high[barIndex], midTermPeriod)
    float highestMidTermValue = ta.highest(high[barIndex], midTermPeriod)
    int lowestMidTermBar = ta.lowestbars(low[barIndex], midTermPeriod)
    float lowestMidTermValue = ta.lowest(low[barIndex], midTermPeriod)

    [highestShortTermBar, highestShortTermValue, lowestShortTermBar, lowestShortTermValue, highestMidTermBar, highestMidTermValue, lowestMidTermBar, lowestMidTermValue]


//
// @function gets a suitable combination of equilibrium periods for the specified scheme.
// @param scheme string, the name of the scheme.
// @returns 4 float values, a best suited combination of equilibrium periods.
//
export getEquilibriumPeriods(string scheme) =>
    switch scheme
        "Custom" => [0, 0, 0, 0]
        "Standard" => [9, 26, 52, 26]
        "Scalper" => [7, 22, 44, 22]
        "5 Day Week" => [8, 22, 44, 22]
        "Popular" => [9, 30, 60, 30]
        "Ideal" => [10, 30, 60, 30]
        "Trend Finder" => [12, 24, 120, 24]
        "Conservative" => [20, 60, 120, 30]
        =>
            runtime.error("Scheme not supported!")
            [int(na), int(na), int(na), int(na)]


//
// @function projects a one glance view of the entire resistance net faced by the price. It does so by computing different equilibrium points for the price.
// @param index, used to pick the last data point for using higher timeframe data in lower timeframe.
// @param shortTermPeriod int, the period for computing the short-term equilibrium point.
// @param midTermPeriod int, the period for computing the intermediate-term equilibrium point.
// @param longTermPeriod int, the period for computing the 2 additional long-term equilibrium points.
// @returns shortTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last shortTermPeriod.
// @returns mideTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last midTermPeriod.
// @returns longTermEquilibriumA float, the midpoint of the shortTermEquilibrium and midTermEquilibrium points.
// @returns longTermEquilibriumB float, the midpoint of highest-high and lowest-low of the candles in last longTermPeriod.
//
export findEquilibrium(int index, int shortTermPeriod, int midTermPeriod, int longTermPeriod) =>
    shortTermEquilibrium = getHighestHighAndLowestLow(index, shortTermPeriod)
    midTermEquilibrium = getHighestHighAndLowestLow(index, midTermPeriod)
    longTermEquilibriumA = math.avg(shortTermEquilibrium, midTermEquilibrium)
    longTermEquilibriumB = getHighestHighAndLowestLow(index, longTermPeriod)
    [shortTermEquilibrium, midTermEquilibrium, longTermEquilibriumA, longTermEquilibriumB]


//
// @function projects a one glance view of the entire resistance net faced by the price. It does so by computing different equilibrium points for the price.
// @param index, used to pick the last data point for using higher timeframe data in lower timeframe.
// @param shortTermPeriod int, the period for computing the short-term equilibrium point.
// @param midTermPeriod int, the period for computing the intermediate-term equilibrium point.
// @param longTermPeriod int, the period for computing the 2 additional long-term equilibrium points.
// @returns open, high, low, and close prices.
// @returns shortTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last shortTermPeriod.
// @returns mideTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last midTermPeriod.
// @returns longTermEquilibriumA float, the midpoint of the shortTermEquilibrium and midTermEquilibrium points.
// @returns longTermEquilibriumB float, the midpoint of highest-high and lowest-low of the candles in last longTermPeriod.
// @returns float, the highest & lowest short-term & mid-term bar and corresponding price.
//
export getAllStrategyParameters(int index, int shortTermPeriod, int midTermPeriod, int longTermPeriod) =>
    shortTermEquilibrium = getHighestHighAndLowestLow(index, shortTermPeriod)
    midTermEquilibrium = getHighestHighAndLowestLow(index, midTermPeriod)
    longTermEquilibriumA = math.avg(shortTermEquilibrium, midTermEquilibrium)
    longTermEquilibriumB = getHighestHighAndLowestLow(index, longTermPeriod)

    [highestShortTermBar,
         highestShortTermValue,
         lowestShortTermBar,
         lowestShortTermValue,
         highestMidTermBar,
         highestMidTermValue,
         lowestMidTermBar,
         lowestMidTermValue] = getHighestHighAndLowestLowSet(shortTermPeriod, midTermPeriod, true)

    [open, high, low, close,
         shortTermEquilibrium, midTermEquilibrium, longTermEquilibriumA, longTermEquilibriumB,
         highestShortTermBar, lowestShortTermBar, highestMidTermBar, lowestMidTermBar]


//
// @function checks the 2 moving averages and establishes whether its bullish or bearish.
// @param fast float, the fast moving point.
// @param slow float, the slow moving point.
// @returns string, it is "bullish" if fast moving point is over the slow moving point o/w returns "bearish".
//
export getBias(float fast, float slow) =>
    float diff = fast - slow
    string view = diff > 0 ? "bullish" : (diff < 0 ? "bearish" : "neutral")
    view


//
// @function checks crossover of 2 moving averages and establishes whether its bullish or bearish.
// @param fast float, the fast moving line.
// @param slow float, the slow moving lline.
// @returns string, it returns "bullish" if fast moving line cosses above the slow moving line o/w returns "bearish".
//
export getBiasFromCrossover(float fast, float slow, bool allowPrematureCross) =>
    string view = na
    if (fast[1] <= slow[1] and fast > slow)
        view := "bullish"
    else if (fast[1] >= slow[1] and fast < slow)
        view := "bearish"
    else if (allowPrematureCross
             and fast[1] == slow[1] and fast == slow)
        view := "neutral"
    
    view


//
// @function determines the placement of price w.r.t the specified resistance/support level.
// @param price float, the price (typically a fast moving average).
// @param level float, the dynamic support/resistance (typically a slow moving average).
// @returns string, the above/below/at position w.r.t level.
//
export getPositionRelativeToLevel(float price, float level) =>
    string position = price > level ? "above" : (price < level ? "below" : "at")
    position


//
// @function determines the placement of price w.r.t a range (i.e. a dynamic resistance band).
// @param price float, the price.
// @param fromLevel float, the from-range which is typically a fast moving line.
// @param toLevel float, the to-range which is typically a slow moving line.
// @returns string, the above/below/within range.
//
export getPositionRelativeToRange(float price, float fromLevel, float toLevel) =>
    string view = getBias(fromLevel, toLevel)
    string position = "within"
    if (view == "bullish" and price > fromLevel)
         or (view == "bearish" and price > toLevel)
        position := "above"
    else if (view == "bullish" and price < toLevel)
         or (view == "bearish" and price < fromLevel)
        position := "below"
    else if (view == "neutral" and price > fromLevel)
        position := "above"
    else if (view == "neutral" and price > toLevel)
        position := "above"
    else if (view == "neutral" and price < toLevel)
        position := "below"
    else if (view == "neutral" and price < fromLevel)
        position := "below"
    else
        position := "within"
    
    position


//
// @function determines how far the price is from a signifcant supply/demand zone (the long-term signficant support/resistance).
// @param price float, the price.
// @param level float, the long-term support or resistance.
// @param span int, the number of candles to consider for calculating the gap.
// @param bias string, the market direction deduced from the crossover of short-term moving-average and mid-term moving-average.
// @param priceWrtResistanceBand string, whether the price is above/below the long-term resistance band.
// @returns float, the gap between the price and the significant level.
//
export getGap(float price, float level, int span, string bias, string priceWrtResistanceBand) =>
    lowest = ta.lowest(level, span)
    highest = ta.highest(level, span)
    
    float gap = 0.0
    if ((bias == "bullish" or bias == "neutral")
         and priceWrtResistanceBand == "above")
         and not na(level)
        gap := price - highest
    else if ((bias == "bearish" or bias == "neutral")
         and priceWrtResistanceBand == "below")
         and not na(level)
        gap := lowest - price
    
    [gap, highest, lowest]


//
// @function determines whether the lagging-span is heading into congestion zone.
// @param price float, the price.
// @param price displacement int, the look-back period.
// @param proximity float, the number of candles which are exepected to not block the laggging-span.
// @param laggingSpanInRelationToPrice string, the position of lagging-span w.r.t price in the look-back period.
// @returns bool, whether the price would face congestion or not.
//
export isLaggingSpanCongestionFree(float price, int displacement, float proximity, float scale, string bias, string laggingSpanInRelationToPrice) =>
    highest = (1-scale/100) * ta.highest(high[displacement-proximity], proximity)
    lowest = (1-scale/100) * ta.lowest(low[displacement-proximity], proximity)
    bias == "bullish" ?
                         (price > highest)
                         : bias == "bearish" ?
                                                 (price < lowest)
                                                 : laggingSpanInRelationToPrice == "above" ?
                                                                 (price > highest)
                                                                 : laggingSpanInRelationToPrice == "below" ? (price < lowest) : true


//
// @function determines the ATR factor using Average True Range.
// @param length float, the ATR length.
// @param multiplier float, the ATR multiplier.
// @returns float, the stop-loss value.
//
export getAtrFactor(simple int length, simple float multiplier) =>
    ta.atr(length) * multiplier


//
// @function determines the stop-loss value by looking at the range (i.e. a dynamic resistance band).
// @param price float, the price.
// @param fromLevel float, the from-range which is typically a fast moving line.
// @param toLevel float, the to-range which is typically a slow moving line.
// @returns float, the stop-loss value.
//
export getStopLossFromRange(float price, float fromLevel, float toLevel) =>
    string bias = getBias(fromLevel, toLevel)
    string priceWrtResistanceBand = getPositionRelativeToRange(price, fromLevel, toLevel)

    float stop = -1
    if not na(fromLevel)
         and not na(toLevel)
        if priceWrtResistanceBand == "above" or priceWrtResistanceBand == "within"
            if bias == "bullish" or bias == "neutral"
                stop := toLevel
            else if bias == "bearish" or bias == "neutral"
                stop := fromLevel
        else if priceWrtResistanceBand == "below"
            if bias == "bullish" or bias == "neutral"
                stop := fromLevel
            else if bias == "bearish" or bias == "neutral"
                stop := toLevel
    
    stop


//
// @function provides all the popular timeframes along with their resolution in minutes.
// @returns array, popular timeframes as an array of strings.
// @ returns array, resolutions as an array of integers.
//
export getResolutions() =>
    timeframes = array.from("1", "5", "15", "30", "45", "60", "120", "180", "240", "360", "720", "D", "2D", "3D", "5D",   "W",  "2W",   "M",   "3M")
    resolutions = array.from( 1,   5,   15,   30,   45,   60,   120,   180,   240,   360,  720, 1440, 2880, 4320, 7200, 10080, 20160, 43200, 129600)
    
    [timeframes, resolutions]


//
// @function determines the higher timeframe for the required order and magnitude.
// @param order float, the factor to go higher by from the current timeframe.
// @param magnitude int, the multiplier.
// @returns string, the higher timeframe identifier.
//
export getHigherTimeframe(float order=1, int magnitude=4) =>
    string htf = na
    
    [timeframes, resolutions] = getResolutions()
    
    ctfIndex = array.indexof(timeframes, timeframe.period)
    size = array.size(resolutions)
    if ctfIndex != -1 and size > 1
        ctfResolution = array.get(resolutions, ctfIndex)
        htfResolution = ctfResolution * math.pow(magnitude, order)
        for i = 1 to size by 1
            r = array.get(resolutions, i)
            if r >= htfResolution
                if (r-htfResolution)/ctfResolution>= 1
                     and i-1 > 0
                    htf := array.get(timeframes, i-1)
                else
                    htf := array.get(timeframes, i)
                break
    htf

