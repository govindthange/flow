//  ██╗    ██╗ ██████╗  ██████╗ ██████╗ ██╗    ██╗██╗███╗   ██╗██████╗     ██╗   ██╗ █████╗ ██████╗ ██████╗ 
//  ██║    ██║██╔═══██╗██╔═══██╗██╔══██╗██║    ██║██║████╗  ██║██╔══██╗    ╚██╗ ██╔╝██╔══██╗██╔══██╗██╔══██╗
//  ██║ █╗ ██║██║   ██║██║   ██║██║  ██║██║ █╗ ██║██║██╔██╗ ██║██║  ██║     ╚████╔╝ ███████║██████╔╝██║  ██║
//  ██║███╗██║██║   ██║██║   ██║██║  ██║██║███╗██║██║██║╚██╗██║██║  ██║      ╚██╔╝  ██╔══██║██╔══██╗██║  ██║
//  ╚███╔███╔╝╚██████╔╝╚██████╔╝██████╔╝╚███╔███╔╝██║██║ ╚████║██████╔╝       ██║   ██║  ██║██║  ██║██████╔╝
//   ╚══╝╚══╝  ╚═════╝  ╚═════╝ ╚═════╝  ╚══╝╚══╝ ╚═╝╚═╝  ╚═══╝╚═════╝        ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ 
//                                                                                                        
// © 2021
// @ govindthange

//
// @version=5
// @description provides ancillary functions to support Woodwind Playbook.
//
library("WoodwindYard", overlay=true)


//
// @function determines the highest-high and the lowest-low value for the specified interval.
// @param period int, the time interval.
// @returns float, the highest-high and lowest-low value.
//
export getHighestHighAndLowestLow(int period) => math.avg(ta.lowest(period), ta.highest(period))


//
// @function determines the highest-high and the lowest-low value for the specified interval.
// @param shortTermPeriod, the short-term equilibrium point period.
// @param midTermPeriod, the intermediate-term equilibrium point period.
// @returns float, the highest & lowest short-term & mid-term bar and corresponding price.
//
export getHighestHighAndLowestLowSet(int shortTermPeriod, int midTermPeriod, bool includeCurrentBar) =>
    int barIndex = includeCurrentBar ? 0 : 1
    int highestShortTermBar = ta.highestbars(high[barIndex], shortTermPeriod)
    float highestShortTermValue = ta.highest(high[barIndex], shortTermPeriod)
    int lowestShortTermBar = ta.lowestbars(low[barIndex], shortTermPeriod)
    float lowestShortTermValue = ta.lowest(low[barIndex], shortTermPeriod)
    int highestMidTermBar = ta.highestbars(high[barIndex], midTermPeriod)
    float highestMidTermValue = ta.highest(high[barIndex], midTermPeriod)
    int lowestMidTermBar = ta.lowestbars(low[barIndex], midTermPeriod)
    float lowestMidTermValue = ta.lowest(low[barIndex], midTermPeriod)

    [highestShortTermBar, highestShortTermValue, lowestShortTermBar, lowestShortTermValue, highestMidTermBar, highestMidTermValue, lowestMidTermBar, lowestMidTermValue]


//
// @function gets a suitable combination of equilibrium periods for the specified scheme.
// @param scheme string, the name of the scheme.
// @returns 4 float values, a best suited combination of equilibrium periods.
//
export getEquilibriumPeriods(string scheme) =>
    switch scheme
        "Custom" => [0, 0, 0, 0]
        "Standard" => [9, 26, 52, 26]
        "Scalper" => [7, 22, 44, 22]
        "5 Day Week" => [8, 22, 44, 22]
        "Popular" => [9, 30, 60, 30]
        "Ideal" => [10, 30, 60, 30]
        "Trend Finder" => [12, 24, 120, 24]
        "Forflies" => [20, 60, 120, 30]
        =>
            runtime.error("Scheme not supported!")
            [int(na), int(na), int(na), int(na)]


//
// @function projects a one glance view of the entire resistance net faced by the price. It does so by computing different equilibrium points for the price.
// @param shortTermPeriod, the period for computing the short-term equilibrium point.
// @param midTermPeriod, the period for computing the intermediate-term equilibrium point.
// @param longTermPeriod, the period for computing the 2 additional long-term equilibrium points.
// @returns shortTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last shortTermPeriod.
// @returns mideTermEquilibrium float, the midpoint of highest-high and lowest-low of the candles in last midTermPeriod.
// @returns longTermEquilibriumA float, the midpoint of the shortTermEquilibrium and midTermEquilibrium points.
// @returns longTermEquilibriumB float, the midpoint of highest-high and lowest-low of the candles in last longTermPeriod.
//
export findEquilibrium(int shortTermPeriod, int midTermPeriod, int longTermPeriod) =>
    shortTermEquilirium = getHighestHighAndLowestLow(shortTermPeriod)
    mideTermEquilibrium = getHighestHighAndLowestLow(midTermPeriod)
    longTermEquilibriumA = math.avg(shortTermEquilirium, mideTermEquilibrium)
    longTermEquilibriumB = getHighestHighAndLowestLow(longTermPeriod)
    [shortTermEquilirium, mideTermEquilibrium, longTermEquilibriumA, longTermEquilibriumB]


//
// @function checks the 2 moving averages and establishes whether its bullish or bearish.
// @param fast float, the fast moving point.
// @param slow float, the slow moving point.
// @returns string, it is "bullish" if fast moving point is over the slow moving point o/w returns "bearish".
//
export getStrength(float fast, float slow) =>
    float diff = fast - slow
    string view = diff > 0 ? "bullish" : (diff < 0 ? "bearish" : "neutral")
    view


//
// @function checks crossover of 2 moving averages and establishes whether its bullish or bearish cross.
// @param fast float, the fast moving line.
// @param slow float, the slow moving lline.
// @returns string, it is "bullish" if fast moving line cosses above the slow moving line o/w bearish.
//
export getCrossoverStrength(float fast, float slow, bool allowPrematureCross) =>
    string view = na
    if (fast[1] <= slow[1] and fast > slow)
        view := "bullish"
    else if (fast[1] >= slow[1] and fast < slow)
        view := "bearish"
    else if (allowPrematureCross
             and fast[1] == slow[1] and fast == slow)
        view := "neutral"
    
    view


//
// @function determines the placement of price w.r.t the specified resistance/support level.
// @param price float, the price (typically a fast moving average).
// @param level float, the dynamic support/resistance (typically a slow moving average).
// @returns string, the above/below/at position w.r.t level.
//
export getPositionRelativeToLevel(float price, float level) =>
    string position = price > level ? "above" : (price < level ? "below" : "at")
    position


//
// @function determines the placement of price w.r.t a range (i.e. a dynamic resistance band).
// @param price float, the price.
// @param fromLevel float, the from-range which is typically a fast moving line.
// @param toLevel float, the to-range which is typically a slow moving line.
// @returns string, the above/below/within range.
//
export getPositionRelativeToRange(float price, float fromLevel, float toLevel) =>
    string view = getStrength(fromLevel, toLevel)
    string position = "within"
    if (view == "bullish" and price > fromLevel)
         or (view == "bearish" and price > toLevel)
        position := "above"
    else if (view == "bullish" and price < toLevel)
         or (view == "bearish" and price < fromLevel)
        position := "below"
    else if (view == "neutral" and price > fromLevel)
        position := "above"
    else if (view == "neutral" and price > toLevel)
        position := "above"
    else if (view == "neutral" and price < toLevel)
        position := "below"
    else if (view == "neutral" and price < fromLevel)
        position := "below"
    else
        position := "within"
    
    position


//
// @function determines how far the lagging-span is from the long-term signficant support/resistance.
// @param price float, the price.
// @param level float, the long-term support or resistance.
// @param strength string, the market direction i.e. the strength of the short-term moving-average and mid-term moving-average crossover.
// @param priceWrtResistanceBand string, whether the price is above/below the long-term resistance net.
// @param laggingSpanWrtResistanceBand string, whether lagging-span is above/below the lagging long-term resistance net.
// @returns float, the proximity of the level.
//
export getProximityRelativeToLevel(float price, float level, string strength, string priceWrtResistanceBand, string laggingSpanWrtResistanceBand, float displacement, int congestionProximity) =>

    lowest = ta.lowest(level[displacement - 1 - congestionProximity], congestionProximity)
    highest = ta.highest(level[displacement - 1 - congestionProximity], congestionProximity)
    
    float proximity = -1.0
    if ((strength == "bullish" or priceWrtResistanceBand == "above")
         and (laggingSpanWrtResistanceBand == "below" or laggingSpanWrtResistanceBand == "within"))
        proximity := (lowest - price)/price
    else if ((strength == "bearish" or priceWrtResistanceBand == "below")
         and (laggingSpanWrtResistanceBand == "above" or laggingSpanWrtResistanceBand == "within"))
        proximity := (price - highest)/price
    
    proximity


//
// @function determines whether the lagging-span is heading into congestion zone.
// @param price float, the price.
// @param price displacement int, the look-back period.
// @param proximity float, the number of candles which are exepected to not block the laggging-span.
// @param laggingSpanInRelationToPrice string, the position of lagging-span w.r.t price in the look-back period.
// @returns bool, whether the price would face congestion or not.
//
export isLaggingSpanCongestionFree(float price, int displacement, float proximity, float scale, string strength, string laggingSpanInRelationToPrice) =>
    highest = (1-scale/100) * ta.highest(high[displacement-proximity], proximity)
    lowest = (1-scale/100) * ta.lowest(low[displacement-proximity], proximity)
    strength == "bullish" ?
                         (price > highest)
                         : strength == "bearish" ?
                                                 (price < lowest)
                                                 : laggingSpanInRelationToPrice == "above" ?
                                                                 (price > highest)
                                                                 : laggingSpanInRelationToPrice == "below" ? (price < lowest) : true


//
// @function determines the ATR factor using Average True Range.
// @param length float, the ATR length.
// @param multiplier float, the ATR multiplier.
// @returns float, the stop-loss value.
//
export getAtrFactor(simple int length, simple float multiplier) =>
    ta.atr(length) * multiplier


//
// @function determines the stop-loss value by looking at the range (i.e. a dynamic resistance band).
// @param price float, the price.
// @param fromLevel float, the from-range which is typically a fast moving line.
// @param toLevel float, the to-range which is typically a slow moving line.
// @returns float, the stop-loss value.
//
export getStopFromRange(float price, float fromLevel, float toLevel) =>
    string strength = getStrength(fromLevel, toLevel)
    string priceWrtResistanceBand = getPositionRelativeToRange(price, fromLevel, toLevel)

    float stop = -1
    if not na(fromLevel)
         and not na(toLevel)
        if priceWrtResistanceBand == "above" or priceWrtResistanceBand == "within"
            if strength == "bullish" or strength == "neutral"
                stop := toLevel
            else if strength == "bearish" or strength == "neutral"
                stop := fromLevel
        else if priceWrtResistanceBand == "below"
            if strength == "bullish" or strength == "neutral"
                stop := fromLevel
            else if strength == "bearish" or strength == "neutral"
                stop := toLevel
    
    stop

