// Ⓣⓗⓐⓝⓖⓔ 🅕🅛🅞🅦
// © 2022
// @ govindthange
//
// @version=5
// @description is a strategy based trading program.
//
indicator("Thange Flow v1.0", shorttitle="Thange/Flow", overlay=true, max_labels_count=250, max_lines_count=500)
import govindthange/WoodwindYardDev/37 as yard
import govindthange/WoodwindVaultDev/1 as vault
import govindthange/ThangeVault/1 as util
import ed56/debugger/2 as debug


//
// Debug utility
//
[console, frame] = debug.debugger(5)

log(string msg) =>
    dummy = msg
    debug.print(console, frame, msg, barstate.islast)


//
// Collect configuration parameters
//

fromDateInput = input.time(timestamp("1 Apr 2021 05:30 +0300"), title="Backtest From Date")
toDateInput = input.time(timestamp("31 Dec 2021 05:30 +0300"), title="Backtest To Date")

bool includeBrokerage = input.bool(true, title="Include brokerage in PnL")
float makerFee = input.float(0.02, minval=0.0, step=0.01, title="Maker Fee")
float takerFee = input.float(0.04, minval=0.0, step=0.01, title="Taker Fee")

bool applyIndianBrokerageStructure = input.bool(true, title="Apply Indian brokerage structure")
float flatFee = input.float(0, minval=0.0, step=1, title="Flat Fee Per Executed Order")
float stt = input.float(0.01, minval=0.0, step=0.01, title="Securities Transaction Tax")
float exchangeTxnFee = input.float(0.002, minval=0.0, step=0.001, title="Exchange Transaction Charges (NSE/BSE)")
float gst = input.float(18, minval=0.0, title="Goods & Services Tax")
float turnoverFee = input.float(10, minval=0, step=10, title="SEBI Turnover Fee (₹ per 1 Crore)")
float stampDuty = input.float(0.002, minval=0, step=100, title="Stamp Duty")

float accountSize = input.float(1000, minval=0.0, title="Account Size")
float maxRisk = input.float(25, minval=0.0, title="Maximum Risk Per Position") / 100
float riskToRewardRatio = input.float(2.0, minval=0.1, step=0.1, title="Risk/Reward Ratio")
float ratioWrtRiskToBeginTrailingSL = input.float (1.0, minval=0.0, title="Nurture Phase Ratio", tooltip="It is a ratio w.r.t R/R. Until this level the programme will not show any exit signals. You should start trailing stop-loss only after the price crosses this level. This level shown by a red/green dotted line above/below the entry signal.")
float exitPercent = input.float(0, minval=0.0, title="Scale-Out %") / 100
float chikouExitPercent = input.float(0, minval=0.0, title="Lagging-Span Exit %", tooltip="This signal will only appear once.") / 100
float takeProfitPercent = input.float(10, minval=0.0, title="Take-Profit %") / 100
int atrLength = input.int(9, minval=0, title="ATR Length", tooltip="Choose higher values for lower timeframes. In BTC use 30 for 4H, and 9 for 5m/15m/1H/6H/12H/D/3D.")
float atrStopMultiplier = input.float(3, minval=0.0, title="ATR Stop Multiplier (ATR x ?)", tooltip="In BTC use 0.1 for 1H, and 1 for 4H/6H/12H/D/3D.")
float atrBreakoutMultiplier = input.float(0.0, minval=0.0, title="ATR Breakout Multiplier (ATR x ?)")

bool ribbonTwistExitEnabled = input.bool(false, title="Show exit signals when ribbon twists")
bool allowPrematureRibbonTwistForTrade = input.bool(false, title="Show entry signal even when ribbon twists prematurely", tooltip="A premature twist occurs when all the EMAs have not come to the opposite side.")
bool allowRibbonTwistExitInNurturePhase = input.bool(true, title="Show exit signals when ribbon twists in nurture phase")
bool allEmaExitToCascade = input.bool(false, title="Allow exit signals to cascade when price crosses EMAs")
bool requireHiLoBreachToInvalidateEmaExit = input.bool(false, title="Enforce Rule: After price reverses and crosses-over the STEP to open below/above it then show next STEP exit signal only after the price again attempts to breach the STEP to the up/down side for long/short position respectively.")
bool showSignalsUponBreakout = input.bool(true, "Show entry signal upon 9-period high/low breakout", tooltip="Do not disable it! When enabled you should place a limit order for entry right at the price dipicted by the gray/green/red line.")
bool allowEntryUponGaps = input.bool(false, "Show entry signals even on gap-up/down candles ( ! )", tooltip="This is not recommended! This setting is only for study purposes.")
bool allowManualExitOnLimitOrderCandles = input.bool(false, "Show exit signals on candles that triggerred Entry, Stop-Loss, or Take-Profit limit-orders", tooltip="Although enabling this shows high profitability it is very difficult to catch the volatility of the market and do entries and exits on the same candle. Disable it if you want more realistic entry/exit signals.")
bool useEmaPeriodFarthestPointAsStop = input.bool(false, title="Use short-term period's farthest high/low point for stop-loss ( ! )", tooltip="This is for study purpose. Enabling this gives mixed performance.")
float breakevenRatio = input.float(0, minval = 0, title="Stop-Loss Breakeven Ratio ( ! )", tooltip="It is a ratio w.r.t the risk. When price reaches this level in nurture phase the stop-loss should be shifted to breakeven. 0 means no breakeven concept to be used. This setting is for study purpose and performance drops drastically for values greater than 0.")

bool useMtf = input.bool(false, "Use Multi-Timeframe Analysis")
string htfResolution1 = input.timeframe("240", title="1st Order Higher Timeframe")
int htfMagnitude1 = input.int(4, minval=3, maxval=6, step=1, title="1st Order Higher Timeframe Magnitude (Current Timeframe x ?)")
bool showSignalsUponBreakoutOfHtf = input.bool(false, "Show entry signal upon 9-period high/low breakout of higher timeframe")

bool showPnl = input.bool(true, title="Show profit & loss summary")
bool showConfluenceInfo = input.bool(true, title="Show confluence Summary")
bool showTradePlan = input.bool(false, title="Show realtime trade plan in a separate table")
bool horizontalTradePlan = input.bool(true, title="Show trade plan table horizontally")
bool highlightTradesWithBackgroundColor = input.bool(true, "Highlight trades with background colors")

int ribbonHighLowCandleSpan = input.int(38, minval=1, title="Ribbon high-low candle span for breakout")
src = input.source(close, title="EMA Ribbon Source")
ema1Period = input.int(20, minval=1, title="EMA-1 period")
ema2Period = input.int(25, minval=1, title="EMA-2 period")
ema3Period = input.int(30, minval=1, title="EMA-3 period")
ema4Period = input.int(35, minval=1, title="EMA-4 period")
ema5Period = input.int(40, minval=1, title="EMA-5 period")
ema6Period = input.int(45, minval=1, title="EMA-6 period")
ema7Period = input.int(50, minval=1, title="EMA-7 period")
ema8Period = input.int(55, minval=1, title="EMA-8 period")
trendPeriod = input.int(200, minval=1, title="Trend Period")
dropCandles = input.int(1, minval=0, title="Drop first N candles")


//########################################################
//########################################################
//####                                                ####
//####                  Declarations                  ####
//####                                                ####
//########################################################
//########################################################

//
// Standard constants
//
YES = 1.0
NO = 0.0

//
// Color definitions
//
sessionColor = color.rgb(0, 0, 0, 100)
exitSignalColor = color.orange

longBgColor = color.rgb(0,255,0,96)
longLineColor = color.rgb(29, 176, 12, 0)
longPrimarySignalColor = color.rgb(29, 176, 12, 30)
longSecondarySignalColor = color.new(longPrimarySignalColor, 60)
shortBgColor = color.rgb(255,0,0,94)
shortLineColor = color.rgb(242, 10, 10, 0)
shortPrimarySignalColor = color.rgb(242, 10, 10, 30)
shortSecondarySignalColor = color.new(shortPrimarySignalColor, 60)

pnlLabelColor = color.new(color.black, 60)
pnlLabelProfitColor = color.green
pnlLabelProfitBgColor = color.new(longPrimarySignalColor, 87)
pnlLabelLossColor = color.red
pnlLabelLossBgColor = color.new(shortPrimarySignalColor, 85)

pnlLabelMaxCapitalColor =  color.new(color.blue, 45)
pnlLabelMaxCapitalTextColor =  color.yellow


// Initialize an empty array to store trading parameters

var context = array.new_float(15)

f_set(_key, _val) => array.set(context, _key, _val)

f_get(_key) => array.get(context, _key)

f_getString(_key) => str.tostring(array.get(context, _key))

f_true(_key) => f_get(_key) == YES

// Declare constants to access global variables
IDX_PriceLevelToBeginTrailingStopLoss = 0
IDX_ShouldExitOnStopLoss = 1
IDX_CanExitAfterRibbonCrossOrTwist = 2
IDX_ShouldExitOnRibbonTwist = 3
IDX_TxCrossPrice = 4

f_reset() =>
    f_set(IDX_PriceLevelToBeginTrailingStopLoss, -1)
    f_set(IDX_ShouldExitOnStopLoss, NO)
    f_set(IDX_CanExitAfterRibbonCrossOrTwist, NO)
    f_set(IDX_ShouldExitOnRibbonTwist, NO)
    f_set(IDX_TxCrossPrice, -1)

f_tradeDirection(long, short) => long ? 1 : (short ? -1 : 0)

var label activeTradeLabel = na
var string activeTradeInfo = na
var label maxCapitalLabel = na
var color maxCapitalLabelBgColor = na
var color maxCapitalLabelTextColor = na

float maxRiskPerPosition = accountSize * maxRisk
var float qty = 0.0
var float qtyPerExit = 0.0
var float qtyPerTakeProfit = 0.0
var float qtyPerRsiExit = 0.0
var float remainingExitQty = 0.0
var int totalTrades = 0
var float tradeSize = 0.0
var float pnl = 0.0

var hasSignaled = false

var inLongTrade = false
var inShortTrade = false

var canPrepareForLong = false
var shouldGoLong = false
var longBreakoutPrice = 0.0
var bool hasSignaledForLong = false
bool didLongPositionClose = false

var canPrepareForShort = false
var shouldGoShort = false
var shortBreakoutPrice = 0.0
var bool hasSignaledForShort = false
bool didShortPositionClose = false

var shouldExitOnEmaCross = false
var shouldExitOnRibbonCross = false
var shouldExitOnRibbonTwist = false
var shouldExitOnStop = false
var shouldTakeProfit = false
var didTakeProfit = false
var shouldExitPreemptively = false
var shouldExitOnRsi = false
var didExitOnRsi = false

var entryPrice = 0.0
var entryBar = -1

var stopLoss = 0.0
var stopLossBar = -1
var breakevenTrigger = 0.0
var takeProfit = 0.0
var takeProfitBar = -1
var emaExit1 = 0.0
var emaExit2 = 0.0
var emaExit3 = 0.0
var emaExit4 = 0.0
var emaExit5 = 0.0
var emaExit6 = 0.0
var emaExit7 = 0.0
var emaExit8 = 0.0
var emaExit9 = 0.0
var emaExit10 = 0.0
var ribbonExit = 0.0
var tkCrossExit = 0.0
var preemptiveExit = 0.0
var chikouExit = 0.0

var stopLossQty = 0.0
var takeProfitQty = 0.0
var emaExitQty1 = 0.0
var emaExitQty2 = 0.0
var emaExitQty3 = 0.0
var emaExitQty4 = 0.0
var emaExitQty5 = 0.0
var emaExitQty6 = 0.0
var emaExitQty7 = 0.0
var emaExitQty8 = 0.0
var emaExitQty9 = 0.0
var emaExitQty10 = 0.0
var ribbonExitQty = 0.0
var tkCrossExitQty = 0.0
var preemptiveExitQty = 0.0
var chikouExitQty = 0.0

var stopLossGains = 0.0
var takeProfitGains = 0.0
var emaExitGains1 = 0.0
var emaExitGains2 = 0.0
var emaExitGains3 = 0.0
var emaExitGains4 = 0.0
var emaExitGains5 = 0.0
var emaExitGains6 = 0.0
var emaExitGains7 = 0.0
var emaExitGains8 = 0.0
var emaExitGains9 = 0.0
var emaExitGains10 = 0.0
var ribbonExitGains = 0.0
var tkCrossExitGains = 0.0
var preemptiveExitGains = 0.0
var chikouExitGains = 0.0


dropn(src, n) =>
    na(src[n]) ? na : src

price = dropn(src, dropCandles)

ema1 = ta.ema(price, ema1Period)
ema2 = ta.ema(price, ema2Period)
ema3 = ta.ema(price, ema3Period)
ema4 = ta.ema(price, ema4Period)
ema5 = ta.ema(price, ema5Period)
ema6 = ta.ema(price, ema6Period)
ema7 = ta.ema(price, ema7Period)
ema8 = ta.ema(price, ema8Period)
emaForTrend = ta.ema(price, trendPeriod)

e1 = plot(ema1, title="MA-1", color=color.new(#fddffd, 70), linewidth=1)
e2 = plot(ema2, title="MA-2", color=color.new(#fdbcfd, 70), linewidth=1)
fill(e1, e2, color=color.new(#fdbcfd, 70))
e3 = plot(ema3, title="MA-3", color=color.new(#fd92fd, 70), linewidth=1)
fill(e2, e3, color=color.new(#fd92fd, 70))
e4 = plot(ema4, title="MA-4", color=color.new(#ff52ff, 70), linewidth=1)
fill(e3, e4, color=color.new(#ff52ff, 70))
e5 = plot(ema5, title="MA-5", color=color.new(#ff24ff, 70), linewidth=1)
fill(e4, e5, color=color.new(#ff24ff, 70))
e6 = plot(ema6, title="MA-6", color=color.new(#d600d6, 70), linewidth=1)
fill(e5, e6, color=color.new(#d600d6, 70))
e7 = plot(ema7, title="MA-7", color=color.new(#ad00ad, 70), linewidth=1)
fill(e6, e7, color=color.new(#ad00ad, 70))
e8 = plot(ema8, title="MA-8", color=color.new(#7a067a, 70), linewidth=1)
fill(e7, e8, color=color.new(#7a067a, 70))
plot(emaForTrend, title="EMA-Trend", color=color.new(#7900d6, 20), linewidth=2)


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░██╗░░██╗████████╗███████╗░░░█████╗░░██████╗░██████╗███████╗░██████╗░██████╗███╗░░░███╗███████╗███╗░░██╗████████╗░░
//░░██║░░██║╚══██╔══╝██╔════╝░░██╔══██╗██╔════╝██╔════╝██╔════╝██╔════╝██╔════╝████╗░████║██╔════╝████╗░██║╚══██╔══╝░░
//░░███████║░░░██║░░░█████╗░░░░███████║╚█████╗░╚█████╗░█████╗░░╚█████╗░╚█████╗░██╔████╔██║█████╗░░██╔██╗██║░░░██║░░░░░
//░░██╔══██║░░░██║░░░██╔══╝░░░░██╔══██║░╚═══██╗░╚═══██╗██╔══╝░░░╚═══██╗░╚═══██╗██║╚██╔╝██║██╔══╝░░██║╚████║░░░██║░░░░░
//░░██║░░██║░░░██║░░░██║░░░░░░░██║░░██║██████╔╝██████╔╝███████╗██████╔╝██████╔╝██║░╚═╝░██║███████╗██║░╚███║░░░██║░░░░░
//░░╚═╝░░╚═╝░░░╚═╝░░░╚═╝░░░░░░░╚═╝░░╚═╝╚═════╝░╚═════╝░╚══════╝╚═════╝░╚═════╝░╚═╝░░░░░╚═╝╚══════╝╚═╝░░╚══╝░░░╚═╝░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

float htfOrder1 = 1 // 1 order up timeframe i.e. 4x of current timeframe
float htfOrder2 = 2 * htfOrder1 // 2 orders up timeframe i.e. 16x of current timeframe
lastCloseoffsetInHtf1 = bar_index % htfMagnitude1
int htfOffset = lastCloseoffsetInHtf1 == 0 ? (not barstate.isrealtime and barstate.isconfirmed ? 0 : htfMagnitude1) : lastCloseoffsetInHtf1

//
// Preference based logic 
// Based on preference following code block can be commented/uncommented.
//
int htfIndex = barstate.isrealtime and not barstate.isconfirmed ? 1 : 0
int ctfIndex = barstate.isrealtime and not barstate.isconfirmed ? 1 : 1

// Approach I: Obtain candle's close in higher timeframe by calling request.security() fn. This gives precise result but you can't change timeframe dynamically!
cHtf1 = request.security(symbol=syminfo.tickerid, timeframe=htfResolution1, expression=close[htfIndex])[ctfIndex]
closeHtf1 = cHtf1//[htfOffset] // Using htfOffset as index would offset data by htfMagnitude1 units and display it in stepped format.

// Approach II. Calculate closeHtf1 using offset. This gives less precise result but you can now change timeframe dynamically.
// closeHtf1 = close[htfOffset] // Commenting above code and uncommenting this line will give less precise result.

highHtf1 = high[htfOffset]
lowHtf1 = low[htfOffset]
[highestEmaBarHtf1,
     highestEmaValueHtf1,
     lowestEmaBarHtf1,
     lowestEmaValueHtf1,
     highestRibbonBarHtf1,
     highestRibbonValueHtf1,
     lowestRibbonBarHtf1,
     lowestRibbonValueHtf1] = yard.getHighestHighAndLowestLowSet(highHtf1, lowHtf1, ema1Period * htfMagnitude1, ribbonHighLowCandleSpan * htfMagnitude1)


// Establish market view in 1st order higher timeframe
string marketViewInHtf1 = "conslidating"
if useMtf
    marketViewInHtf1 := "conslidating"


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░░█████╗░████████╗███████╗░░░█████╗░░██████╗░██████╗███████╗░██████╗░██████╗███╗░░░███╗███████╗███╗░░██╗████████╗░░
//░░██╔══██╗╚══██╔══╝██╔════╝░░██╔══██╗██╔════╝██╔════╝██╔════╝██╔════╝██╔════╝████╗░████║██╔════╝████╗░██║╚══██╔══╝░░
//░░██║░░╚═╝░░░██║░░░█████╗░░░░███████║╚█████╗░╚█████╗░█████╗░░╚█████╗░╚█████╗░██╔████╔██║█████╗░░██╔██╗██║░░░██║░░░░░
//░░██║░░██╗░░░██║░░░██╔══╝░░░░██╔══██║░╚═══██╗░╚═══██╗██╔══╝░░░╚═══██╗░╚═══██╗██║╚██╔╝██║██╔══╝░░██║╚████║░░░██║░░░░░
//░░╚█████╔╝░░░██║░░░██║░░░░░░░██║░░██║██████╔╝██████╔╝███████╗██████╔╝██████╔╝██║░╚═╝░██║███████╗██║░╚███║░░░██║░░░░░
//░░░╚════╝░░░░╚═╝░░░╚═╝░░░░░░░╚═╝░░╚═╝╚═════╝░╚═════╝░╚══════╝╚═════╝░╚═════╝░╚═╝░░░░░╚═╝╚══════╝╚═╝░░╚══╝░░░╚═╝░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

ribbon = emaForTrend

priceWrtRibbon = "within"
if close > ema1 and close >= ema2 and close >= ema3 and close >= ema4 and close >= ema5 and close >= ema6 and close >= ema7 and close >= ema8
    priceWrtRibbon := "above"
else if close < ema1 and close <= ema2 and close <= ema3 and close <= ema4 and close <= ema5 and close <= ema6 and close <= ema7 and close <= ema8
    priceWrtRibbon := "below"

chikouWrtPrice = priceWrtRibbon

// Establish market view through confluence 
string marketView = "conslidating"
if ema1 >= ema2 and ema2 >= ema3 and ema3 >= ema4 and ema4 >= ema5 and ema5 >= ema6 and ema7 >= ema8
    //  and not (ema1[1] >= ema2[1] and ema2[1] >= ema3[1] and ema3[1] >= ema4[1] and ema4[1] >= ema5[1] and ema5[1] >= ema6[1] and ema7[1] >= ema8[1])
    //  and not (ema1[2] >= ema2[2] and ema2[2] >= ema3[2] and ema3[2] >= ema4[2] and ema4[2] >= ema5[2] and ema5[2] >= ema6[2] and ema7[2] >= ema8[2])
     and ema8 >= emaForTrend
     and priceWrtRibbon == "above"
    marketView := "bullish"
else if ema1 <= ema2 and ema2 <= ema3 and ema3 <= ema4 and ema4 <= ema5 and ema5 <= ema6 and ema7 <= ema8
     and ema8 <= emaForTrend
    //  and not (ema1[1] <= ema2[1] and ema2[1] <= ema3[1] and ema3[1] <= ema4[1] and ema4[1] <= ema5[1] and ema5[1] <= ema6[1] and ema7[1] <= ema8[1])
    //  and not (ema1[2] <= ema2[2] and ema2[2] <= ema3[2] and ema3[2] <= ema4[2] and ema4[2] <= ema5[2] and ema5[2] <= ema6[2] and ema7[2] <= ema8[2])
     and ema8 <= emaForTrend
     and priceWrtRibbon == "below"
    marketView := "bearish"

log(str.format("marketView: {0}", marketView))

[highestEmaBar,
     highestEmaValue,
     lowestEmaBar,
     lowestEmaValue,
     highestRibbonBar,
     highestRibbonValue,
     lowestRibbonBar,
     lowestRibbonValue] = yard.getHighestHighAndLowestLowSet(high[1], low[1], ribbonHighLowCandleSpan, ribbonHighLowCandleSpan)
// log(str.format("Before highest Bar: {0} ({1}), lowest Bar: {2}({3})", highestEmaValue, highestEmaBar, lowestEmaValue, lowestEmaBar))


int breakoutCandleRange = ema1Period + 1
float highestBreakoutPrice = highestEmaValue
int highestBreakoutCandleoffset = highestEmaBar - 1
float lowestBreakoutPrice = lowestEmaValue
int lowestBreakoutCandleOffset = lowestEmaBar - 1

if useMtf and showSignalsUponBreakoutOfHtf
         and (highestEmaValue <= highestEmaValueHtf1
                 or lowestEmaValue >= lowestEmaValueHtf1)
    
    breakoutCandleRange := ema1Period * htfMagnitude1 + htfMagnitude1
    if highestEmaValue < highestEmaValueHtf1
        highestBreakoutCandleoffset := highestEmaBarHtf1 - htfMagnitude1
        highestBreakoutPrice := highestEmaValueHtf1
        highestEmaBar := highestEmaBarHtf1 - htfMagnitude1
        highestEmaValue := highestEmaValueHtf1
    else
        highestBreakoutCandleoffset := highestEmaBar
        highestBreakoutPrice := highestEmaValue

    if lowestEmaValue > lowestEmaValueHtf1
        lowestBreakoutCandleOffset := lowestEmaBarHtf1 - htfMagnitude1
        lowestBreakoutPrice := lowestEmaValueHtf1
        lowestEmaBar := lowestEmaBarHtf1 - htfMagnitude1
        lowestEmaValue := lowestEmaValueHtf1
    else
        lowestBreakoutCandleOffset := lowestEmaBar
        lowestBreakoutPrice := lowestEmaValue
    
    // log(str.format("After highest Bar: {0} ({1}), lowest Bar: {2}({3})", highestEmaValue, highestEmaBar, lowestEmaValue, lowestEmaBar))


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░███████╗███╗░░██╗████████╗██████╗░██╗░░░██╗░░
//░░██╔════╝████╗░██║╚══██╔══╝██╔══██╗╚██╗░██╔╝░░
//░░█████╗░░██╔██╗██║░░░██║░░░██████╔╝░╚████╔╝░░░
//░░██╔══╝░░██║╚████║░░░██║░░░██╔══██╗░░╚██╔╝░░░░
//░░███████╗██║░╚███║░░░██║░░░██║░░██║░░░██║░░░░░
//░░╚══════╝╚═╝░░╚══╝░░░╚═╝░░░╚═╝░░╚═╝░░░╚═╝░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// Determine stop-loss factor using ATR
float atr = ta.atr(atrLength) * atrStopMultiplier

highestBreakoutPrice := highestBreakoutPrice + (atr * atrBreakoutMultiplier)
lowestBreakoutPrice := lowestBreakoutPrice - (atr * atrBreakoutMultiplier)

bool withinTestRange = (time >= fromDateInput and time <= toDateInput)

bool didCandleGap = (open > high[1] and low > high[1]) or (open < low[1] and high < low[1])

//
// Long Entry Strategy
//
canPrepareForLong := (hasSignaled and false)
                     or (withinTestRange
                         and (allowEntryUponGaps or not didCandleGap)
                         and not inLongTrade
                         and not inShortTrade
                         and marketView == "bullish"
                         and (not useMtf or marketViewInHtf1 == "bullish"))

if showSignalsUponBreakout
    if not canPrepareForLong
        hasSignaledForLong := false
        longBreakoutPrice := 0.0
    else if canPrepareForLong and not hasSignaledForLong
        longBreakoutPrice := highestBreakoutPrice
        // Draw 9-period high line to indicate the best entry point
        line.new(bar_index-breakoutCandleRange, highestBreakoutPrice, bar_index, highestBreakoutPrice, width=1, color=color.silver, style=line.style_dotted)
        line.new(bar_index+highestBreakoutCandleoffset, highestBreakoutPrice, bar_index, highestBreakoutPrice, width=1, color=color.gray, style=line.style_solid)
else if canPrepareForLong
    // Draw 9-period high line to indicate the best entry point
    line.new(bar_index-ema1Period, highestBreakoutPrice, bar_index, highestBreakoutPrice, width=1, color=color.silver, style=line.style_dotted)
    line.new(bar_index+highestBreakoutCandleoffset, highestBreakoutPrice, bar_index, highestBreakoutPrice, width=1, color=color.gray, style=line.style_solid)

if canPrepareForLong
     and (not showSignalsUponBreakout or high >= longBreakoutPrice)

    hasSignaled := true
    
    shouldGoLong := true
    hasSignaledForLong := false
    inLongTrade := true
    entryBar := bar_index
    shouldExitOnRibbonCross := false
    
    entryPrice := showSignalsUponBreakout ? longBreakoutPrice : close
    longBreakoutPrice := 0.0

    stopLoss := low - atr
    
    takeProfit := entryPrice + (entryPrice - stopLoss) * riskToRewardRatio * f_tradeDirection(inLongTrade, inShortTrade)
    
    qty := maxRiskPerPosition / (entryPrice - stopLoss)
    qtyPerExit := qty * exitPercent
    qtyPerTakeProfit := qty * takeProfitPercent
    qtyPerRsiExit := qty * chikouExitPercent
    remainingExitQty := qty
    tradeSize := qty * entryPrice
    
    breakevenTrigger := entryPrice + (entryPrice - stopLoss) * breakevenRatio
    array.set(context, IDX_PriceLevelToBeginTrailingStopLoss, entryPrice + (entryPrice - stopLoss) * ratioWrtRiskToBeginTrailingSL)
    line.new(bar_index, f_get(IDX_PriceLevelToBeginTrailingStopLoss), bar_index+10, f_get(IDX_PriceLevelToBeginTrailingStopLoss), width=2, color=longLineColor, style=line.style_dotted)
    line.new(bar_index, stopLoss, bar_index+10, stopLoss, width=2, color=longLineColor, style=line.style_solid)
    
    activeTradeInfo := str.format("#{0}. Buy {1} w/ {2, number, currency}\nEntry @ {3, number, currency}\nStop @ {4, number, currency}\nProfit @ {5, number, currency} ({6} R/R)", totalTrades+1, str.tostring(qty), tradeSize, entryPrice, stopLoss, takeProfit, riskToRewardRatio)
    activeTradeLabel := label.new(x = bar_index,
                             y = low,
                             style = label.style_label_up,
                             color = pnlLabelLossBgColor,
                             textcolor = pnlLabelLossColor,
                             yloc = yloc.belowbar,
                             text = "Long",
                             tooltip = activeTradeInfo)

//
// Short Entry Strategy
//
canPrepareForShort := (hasSignaled and false)
                         or (withinTestRange
                         and (allowEntryUponGaps or not didCandleGap)
                         and not inShortTrade
                         and not inLongTrade
                         and marketView == "bearish"
                         and (not useMtf or marketViewInHtf1 == "bearish"))

if showSignalsUponBreakout
    if not canPrepareForShort
        hasSignaledForShort := false
        shortBreakoutPrice := 0.0
    else if canPrepareForShort and not hasSignaledForShort
        shortBreakoutPrice := lowestBreakoutPrice
        // Draw 9-period high line to indicate the best entry point
        line.new(bar_index-breakoutCandleRange, lowestBreakoutPrice, bar_index, lowestBreakoutPrice, width=1, color=color.silver, style=line.style_dotted)
        line.new(bar_index+lowestBreakoutCandleOffset, lowestBreakoutPrice, bar_index, lowestBreakoutPrice, width=1, color=color.gray, style=line.style_solid)
else if canPrepareForShort
    // Draw 9-period high line to indicate the best entry point
    line.new(bar_index-breakoutCandleRange, lowestBreakoutPrice, bar_index, lowestBreakoutPrice, width=1, color=color.silver, style=line.style_dotted)
    line.new(bar_index+lowestBreakoutCandleOffset, lowestBreakoutPrice, bar_index, lowestBreakoutPrice, width=1, color=color.gray, style=line.style_solid)

if canPrepareForShort
     and (not showSignalsUponBreakout or low <= shortBreakoutPrice)
    
    hasSignaled := true
    
    shouldGoShort := true
    hasSignaledForShort := false
    inShortTrade := true
    entryBar := bar_index
    shouldExitOnRibbonCross := false
    
    entryPrice := showSignalsUponBreakout ? shortBreakoutPrice : close
    shortBreakoutPrice := 0.0

    stopLoss := high + atr
    
    takeProfit := entryPrice - (stopLoss - entryPrice) * riskToRewardRatio
    
    qty := maxRiskPerPosition / (stopLoss - entryPrice)
    qtyPerExit := qty * exitPercent
    qtyPerTakeProfit := qty * takeProfitPercent
    qtyPerRsiExit := qty * chikouExitPercent
    remainingExitQty := qty
    tradeSize := qty * entryPrice
    
    breakevenTrigger := entryPrice - (stopLoss - entryPrice) * breakevenRatio
    array.set(context, IDX_PriceLevelToBeginTrailingStopLoss, entryPrice - (stopLoss - entryPrice) * ratioWrtRiskToBeginTrailingSL)
    line.new(bar_index, f_get(IDX_PriceLevelToBeginTrailingStopLoss), bar_index+10, f_get(IDX_PriceLevelToBeginTrailingStopLoss), width=2, color=shortLineColor, style=line.style_dotted)
    line.new(bar_index, stopLoss, bar_index+10, stopLoss, width=2, color=shortLineColor, style=line.style_solid)
    
    activeTradeInfo := str.format("#{0}. Sell {1} w/ {2, number, currency}\nEntry @ {3, number, currency}\nStop @ {4, number, currency}\nProfit @ {5, number, currency} ({6} R/R)", totalTrades+1, str.tostring(qty), tradeSize, entryPrice, stopLoss, takeProfit, riskToRewardRatio)
    activeTradeLabel := label.new(x = bar_index,
                             y = high,
                             style = label.style_label_down,
                             color = pnlLabelLossBgColor,
                             textcolor = pnlLabelLossColor,
                             yloc = yloc.abovebar,
                             text = "Short",
                             tooltip = activeTradeInfo)


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░███████╗██╗░░██╗██╗████████╗░░
//░░██╔════╝╚██╗██╔╝██║╚══██╔══╝░░
//░░█████╗░░░╚███╔╝░██║░░░██║░░░░░
//░░██╔══╝░░░██╔██╗░██║░░░██║░░░░░
//░░███████╗██╔╝╚██╗██║░░░██║░░░░░
//░░╚══════╝╚═╝░░╚═╝╚═╝░░░╚═╝░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

if ((inLongTrade and high >= takeProfit)
         or (inShortTrade and low <= takeProfit))
     and not didTakeProfit
     and remainingExitQty > 0
    
    shouldTakeProfit := true
    takeProfitBar := bar_index
    [_qty, _remainingQty, _gains] = vault.computeExitGains(entryPrice, takeProfit, qtyPerTakeProfit, remainingExitQty, f_tradeDirection(inLongTrade, inShortTrade))
    takeProfitQty := _qty
    takeProfitGains := _gains
    pnl := pnl + _gains
    remainingExitQty := _remainingQty
    activeTradeInfo += str.format("\nTP {0, number} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", _qty, takeProfit, _gains, pnl)
    label.set_tooltip(activeTradeLabel, activeTradeInfo)


// if ((inLongTrade and chikouWrtPrice == "below")
//          or (inShortTrade and chikouWrtPrice == "above"))
//      and not didExitOnRsi
//      and remainingExitQty > 0
//      and qtyPerRsiExit > 0
    
//     shouldExitOnRsi := true
//     chikouExit := close
//     [_qty, _remainingQty, _gains] = vault.computeExitGains(entryPrice, close, qtyPerRsiExit, remainingExitQty, f_tradeDirection(inLongTrade, inShortTrade))
//     chikouExitQty := _qty
//     chikouExitGains := _gains
//     pnl := pnl + _gains
//     remainingExitQty := _remainingQty
//     activeTradeInfo += str.format("\nCE {0, number} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", _qty, close, _gains, pnl)
//     label.set_tooltip(activeTradeLabel, activeTradeInfo)


if (inLongTrade and high > f_get(IDX_PriceLevelToBeginTrailingStopLoss))
     or (inShortTrade and low < f_get(IDX_PriceLevelToBeginTrailingStopLoss))
    f_set(IDX_CanExitAfterRibbonCrossOrTwist, YES)


if ((inLongTrade and high >= breakevenTrigger)
         or (inShortTrade and low <= breakevenTrigger))
     and breakevenRatio != 0.0
     and not f_true(IDX_CanExitAfterRibbonCrossOrTwist)
    
    stopLoss := entryPrice
    line.new(bar_index, breakevenTrigger, bar_index+5, breakevenTrigger, width=2, color=color.white, style=line.style_solid)


//
// Since Price-Ribbon-Crossover event is for trailing the stop-loss, the old stop-loss order is valid only
// if the trade is in nurture phase (i.e. IDX_CanExitAfterRibbonCrossOrTwist = false)
//
if ((inLongTrade and low <= stopLoss)
         or (inShortTrade and high >= stopLoss))
     and not f_true(IDX_CanExitAfterRibbonCrossOrTwist)
    
    f_set(IDX_ShouldExitOnStopLoss, YES)
    shouldExitOnStop := true
    stopLossBar := bar_index
    stopLossGains := (stopLoss - entryPrice) * remainingExitQty * f_tradeDirection(inLongTrade, inShortTrade)
    pnl := pnl + stopLossGains
    activeTradeInfo += str.format("\nSL {0} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", str.tostring(remainingExitQty), stopLoss, stopLossGains, pnl)
    label.set_tooltip(activeTradeLabel, activeTradeInfo)
    remainingExitQty := 0

else if ((inLongTrade and priceWrtRibbon == "below")
         or (inShortTrade and priceWrtRibbon == "above"))
     and f_true(IDX_CanExitAfterRibbonCrossOrTwist)
     and (allowManualExitOnLimitOrderCandles
             or (bar_index != entryBar and bar_index != stopLossBar and bar_index != takeProfitBar))
    
    shouldExitOnRibbonCross := true
    ribbonExit := close
    if (inLongTrade and ribbonExit < stopLoss)
         or (inShortTrade and ribbonExit > stopLoss)
        ribbonExitGains := (stopLoss - entryPrice) * remainingExitQty * f_tradeDirection(inLongTrade, inShortTrade)
        pnl := pnl + ribbonExitGains
        activeTradeInfo += str.format("\nRE~SL {0} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", str.tostring(remainingExitQty), stopLoss, ribbonExitGains, pnl)
    else
        ribbonExitGains := (ribbonExit - entryPrice) * remainingExitQty * f_tradeDirection(inLongTrade, inShortTrade)
        pnl := pnl + ribbonExitGains
        activeTradeInfo += str.format("\nRE {0} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", str.tostring(remainingExitQty), ribbonExit, ribbonExitGains, pnl)
    label.set_tooltip(activeTradeLabel, activeTradeInfo)
    remainingExitQty := 0

else if ((inLongTrade and marketView == "bearish")
         or (inShortTrade and marketView == "bullish"))
    
    shouldExitPreemptively := true
    if (inLongTrade and close < stopLoss)
         or (inShortTrade and close > stopLoss)
        preemptiveExitGains := (stopLoss - entryPrice) * remainingExitQty * f_tradeDirection(inLongTrade, inShortTrade)
        pnl := pnl + preemptiveExitGains
        activeTradeInfo += str.format("\nPE~SL {0} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", str.tostring(remainingExitQty), stopLoss, preemptiveExitGains, pnl) // PE is Preemptive Exit
    else
        preemptiveExitGains := (close - entryPrice) * remainingExitQty * f_tradeDirection(inLongTrade, inShortTrade)
        pnl := pnl + preemptiveExitGains
        activeTradeInfo += str.format("\nPE {0} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", str.tostring(remainingExitQty), close, preemptiveExitGains, pnl) // PE is Preemptive Exit
    label.set_tooltip(activeTradeLabel, activeTradeInfo)
    remainingExitQty := 0
//
// Since all tenkan-exits are manually placed orders they can only be placed when the other 2 limit-orders,
// the kijun-exit (a trailing stop) or the stop-loss (automatically triggerred order) are not triggerred yet.
// You'll also not bother scaling out gains by placing a tenkan-exit order when a ribbon-twist/preemptive-exits has occurred.
//
else if exitPercent > 0
     and ((allEmaExitToCascade
             and ((inLongTrade
                         and open < ema1
                         and ((requireHiLoBreachToInvalidateEmaExit and high <= ema1) or not requireHiLoBreachToInvalidateEmaExit))
                     or (inShortTrade
                             and open > ema1
                             and ((requireHiLoBreachToInvalidateEmaExit and low >= ema1) or not requireHiLoBreachToInvalidateEmaExit))))
     or (not allEmaExitToCascade
                 and ((inLongTrade and open < ema1
                             and ((requireHiLoBreachToInvalidateEmaExit and high <= ema1) or not requireHiLoBreachToInvalidateEmaExit)
                             and high[1] > ema1[1])
                         or (inShortTrade and open > ema1
                                 and ((requireHiLoBreachToInvalidateEmaExit and low >= ema1) or not requireHiLoBreachToInvalidateEmaExit)
                                 and low[1] < ema1[1]))))
     and remainingExitQty > 0
     and (allowManualExitOnLimitOrderCandles
             or ema1[1] == ema1[0]
             or (bar_index != entryBar and bar_index != stopLossBar and bar_index != takeProfitBar))
    
    shouldExitOnEmaCross := true
    [_qty, _remainingQty, _gains] = vault.computeExitGains(entryPrice, close, qtyPerExit, remainingExitQty, f_tradeDirection(inLongTrade, inShortTrade))
    pnl := pnl + _gains
    remainingExitQty := _remainingQty
    activeTradeInfo += str.format("\nEE {0, number} @ {1, number, currency} = {2, number, currency}/{3, number, currency}", _qty, close, _gains, pnl)
        
    if (emaExit1 == 0.0)
        emaExit1 := close
        emaExitQty1 := _qty
        emaExitGains1 := _gains
    
    else if (emaExit2 == 0.0)
        emaExit2 := close
        emaExitQty2 := _qty
        emaExitGains2 := _gains
    
    else if (emaExit3 == 0.0)
        emaExit3 := close
        emaExitQty3 := _qty
        emaExitGains3 := _gains
    
    else if (emaExit4 == 0.0)
        emaExit4 := close
        emaExitQty4 := _qty
        emaExitGains4 := _gains
    
    else if (emaExit5 == 0.0)
        emaExit5 := close
        emaExitQty5 := _qty
        emaExitGains5 := _gains
    
    else if (emaExit6 == 0.0)
        emaExit6 := close
        emaExitQty6 := _qty
        emaExitGains6 := _gains
    
    else if (emaExit7 == 0.0)
        emaExit7 := close
        emaExitQty7 := _qty
        emaExitGains7 := _gains
    
    else if (emaExit8 == 0.0)
        emaExit8 := close
        emaExitQty8 := _qty
        emaExitGains8 := _gains
    
    else if (emaExit9 == 0.0)
        emaExit9 := close
        emaExitQty9 := _qty
        emaExitGains9 := _gains
    
    else if (emaExit10 == 0.0)
        emaExit10 := close
        emaExitQty10 := _qty
        emaExitGains10 := _gains
    
    label.set_tooltip(activeTradeLabel, activeTradeInfo)
else
    shouldExitOnEmaCross := false


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░░██████╗██╗░██████╗░███╗░░██╗░█████╗░██╗░░░░░░██████╗░░
//░░██╔════╝██║██╔════╝░████╗░██║██╔══██╗██║░░░░░██╔════╝░░
//░░╚█████╗░██║██║░░██╗░██╔██╗██║███████║██║░░░░░╚█████╗░░░
//░░░╚═══██╗██║██║░░╚██╗██║╚████║██╔══██║██║░░░░░░╚═══██╗░░
//░░██████╔╝██║╚██████╔╝██║░╚███║██║░░██║███████╗██████╔╝░░
//░░╚═════╝░╚═╝░╚═════╝░╚═╝░░╚══╝╚═╝░░╚═╝╚══════╝╚═════╝░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

plotshape(inLongTrade and marketView == "bearish" and shouldExitPreemptively, title= "Preeemptive Long Exit", location=location.belowbar, color=longPrimarySignalColor, style=shape.flag, text="", size=size.small, editable=false)
plotshape(inShortTrade and marketView == "bullish" and shouldExitPreemptively, title= "Preeemptive Short Exit", location=location.belowbar, color=shortPrimarySignalColor, style=shape.flag, text="", size=size.small, editable=false)

plotshape(showSignalsUponBreakout and canPrepareForLong and not hasSignaledForLong and not shouldGoLong, title= "Prepare to go long", location=location.belowbar, color=color.teal, style=shape.triangleup, text="", size=size.tiny, editable=false)
if showSignalsUponBreakout and canPrepareForLong
    canPrepareForLong := false // reset flag
    if showSignalsUponBreakout
        hasSignaledForLong := true

plotshape(showSignalsUponBreakout and canPrepareForShort and not hasSignaledForShort and not shouldGoShort, title= "Prepare to go short", location=location.abovebar, color=color.red, style=shape.triangledown, text="", size=size.tiny, editable=false)
if showSignalsUponBreakout and canPrepareForShort
    canPrepareForShort := false // reset flag
    if showSignalsUponBreakout
        hasSignaledForShort := true

plotshape(inLongTrade and ((showSignalsUponBreakout and shouldGoLong) or (not showSignalsUponBreakout and canPrepareForLong)), title="Long Entry", location=location.belowbar, color=longPrimarySignalColor, style=shape.triangleup, text="", size=size.small, editable=false)
if not showSignalsUponBreakout
    canPrepareForLong := false
else if shouldGoLong
    shouldGoLong := false

plotshape(inShortTrade and ((showSignalsUponBreakout and shouldGoShort) or (not showSignalsUponBreakout and canPrepareForShort)), title= "Short Entry", location=location.abovebar, color=shortPrimarySignalColor, style=shape.triangledown, text="", size=size.small, editable=false)
if not showSignalsUponBreakout
    canPrepareForShort := false
else if shouldGoShort
    shouldGoShort := false

plotshape(inLongTrade and shouldExitOnEmaCross, title= "Ema Long Exit", location=location.abovebar, color= (remainingExitQty <= 0 ? exitSignalColor : longSecondarySignalColor), style=shape.diamond, text="", size=size.tiny, editable=false)
plotshape(inShortTrade and shouldExitOnEmaCross, title= "Ema Short Exit", location=location.belowbar, color= (remainingExitQty <= 0 ? exitSignalColor : shortSecondarySignalColor), style=shape.diamond, text="", size=size.tiny, editable=false)

plotshape(inLongTrade and shouldExitOnRibbonCross, title= "Ribbon Long Exit", location=location.abovebar, color=longSecondarySignalColor, style=shape.circle, text="", size=size.tiny, editable=false)
plotshape(inShortTrade and shouldExitOnRibbonCross, title= "Ribbon Short Exit", location=location.belowbar, color=shortSecondarySignalColor, style=shape.circle, text="", size=size.tiny, editable=false)

plotshape(inLongTrade and shouldExitOnRibbonTwist, title= "Ribbon Twist Long Exit", location=location.abovebar, color=longSecondarySignalColor, style=shape.xcross, text="", size=size.small, editable=false)
plotshape(inShortTrade and shouldExitOnRibbonTwist, title= "Ribbon Twist Short Exit", location=location.belowbar, color=shortSecondarySignalColor, style=shape.xcross, text="", size=size.small, editable=false)

plotshape(inLongTrade and (f_true(IDX_ShouldExitOnStopLoss) or shouldExitOnStop), title= "Stop Loss Long Exit", location=location.belowbar, color=longPrimarySignalColor, style=shape.flag, text="", size=size.small, editable=false)
plotshape(inShortTrade and inShortTrade and (f_true(IDX_ShouldExitOnStopLoss) or shouldExitOnStop), title= "Stop Loss Short Exit", location=location.abovebar, color=shortPrimarySignalColor, style=shape.flag, text="", size=size.small, editable=false)

plotshape(inLongTrade and shouldTakeProfit, title= "Fixed Long Exit", location=location.abovebar, color= (remainingExitQty <= 0 ? exitSignalColor : longSecondarySignalColor), style=shape.square, text="", size=size.tiny, editable=false)
plotshape(inShortTrade and shouldTakeProfit, title= "Fixed Short Exit", location=location.belowbar, color= (remainingExitQty <= 0 ? exitSignalColor : shortSecondarySignalColor), style=shape.square, text="", size=size.tiny, editable=false)

plotshape(inLongTrade and shouldExitOnRsi, title= "Rsi Long Exit", location=location.abovebar, color= (remainingExitQty <= 0 ? exitSignalColor : color.white), style=shape.diamond, text="", size=size.tiny, editable=false)
plotshape(inShortTrade and shouldExitOnRsi, title= "Rsi Short Exit", location=location.belowbar, color= (remainingExitQty <= 0 ? exitSignalColor : color.white), style=shape.diamond, text="", size=size.tiny, editable=false)

if shouldTakeProfit
    didTakeProfit := true
    shouldTakeProfit := false

if shouldExitOnRsi
    didExitOnRsi := true
    shouldExitOnRsi := false

//###################################################################
//###################################################################
//####                                                           ####
//####                  Flag variables for exit                  ####
//####                                                           ####
//###################################################################
//###################################################################

if (inLongTrade and (shouldExitOnRibbonCross or f_true(IDX_ShouldExitOnStopLoss) or shouldExitOnRibbonTwist or shouldExitPreemptively or remainingExitQty <= 0))
    inLongTrade := false
    f_reset()
    didLongPositionClose := true
    if showSignalsUponBreakout
        hasSignaledForLong := false
        canPrepareForLong := false

if (inShortTrade and (shouldExitOnRibbonCross or f_true(IDX_ShouldExitOnStopLoss) or shouldExitOnRibbonTwist or shouldExitPreemptively or remainingExitQty <= 0))
    inShortTrade := false
    f_reset()
    didShortPositionClose := true
    if showSignalsUponBreakout
        hasSignaledForShort := false
        canPrepareForShort := false

//
// Draw background color
//
if inLongTrade and highlightTradesWithBackgroundColor
    sessionColor := longBgColor
else if inShortTrade and highlightTradesWithBackgroundColor
    sessionColor := shortBgColor
else if withinTestRange
    sessionColor := color.rgb(0, 0, 0, 60)

bgcolor(sessionColor, editable=false)


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░██████╗░███╗░░██╗██╗░░░░░░░
//░░██╔══██╗████╗░██║██║░░░░░░░
//░░██████╔╝██╔██╗██║██║░░░░░░░
//░░██╔═══╝░██║╚████║██║░░░░░░░
//░░██║░░░░░██║░╚███║███████╗░░
//░░╚═╝░░░░░╚═╝░░╚══╝╚══════╝░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

var int totalCandles = 0
if withinTestRange
    totalCandles := totalCandles + 1

var int winners = 0
var int hotStreak = 0
var int maxHotStreak = 0
var float hotStreakGains = 0.0
var float maxHotStreakGains = 0.0

var int loosers = 0
var int coldStreak = 0
var int maxColdStreak = 0
var float coldStreakLoss = 0.0
var float maxColdStreakLoss = 0.0

var float cumulativeCapital = 0.0
var float maxCapital = 0.0
var float totalPnl = 0.0
var float totalPnlPercent = 0.0
var float totalProfit = 0.0
var float totalLoss = 0.0
var float prevPnl = 0.0
var float prevPnlPercent = 0.0
var float maxProfit = 0.0
var float maxLoss = 0.0

float realtime = 0.0
float totalCharges = 0.0
string chargeDescrption = na

if inLongTrade or inShortTrade
    realtime := (close - entryPrice) * remainingExitQty * f_tradeDirection(inLongTrade, inShortTrade)

    if includeBrokerage
        float averageExitPrice = ((entryPrice * qty) + pnl + realtime) / qty
        if applyIndianBrokerageStructure
            [_charges, _chargeDesc] = vault.calculateCharges(entryPrice, averageExitPrice, qty, f_tradeDirection(inLongTrade, inShortTrade), makerFee, takerFee,
                                                                 flatFee = flatFee,
                                                                 txnFee = exchangeTxnFee,
                                                                 stt = stt,
                                                                 gst = gst,
                                                                 turnoverFee = turnoverFee,
                                                                 stampDuty = stampDuty)
            totalCharges := _charges
            chargeDescrption := _chargeDesc
        else
            [_charges, _chargeDesc] = vault.calculateCharges(entryPrice, averageExitPrice, qty, f_tradeDirection(inLongTrade, inShortTrade), makerFee, takerFee)
            totalCharges := _charges
            chargeDescrption := _chargeDesc

if (activeTradeLabel != na
     and (inLongTrade or inShortTrade))
    
    float tempPnl = pnl + realtime - totalCharges
    label.set_color(activeTradeLabel, (tempPnl > 0 ? pnlLabelProfitBgColor : pnlLabelLossBgColor))
    label.set_textcolor(activeTradeLabel, (tempPnl > 0 ? pnlLabelProfitColor : pnlLabelLossColor))
    label.set_text(activeTradeLabel, str.format("{0, number, currency}\n{1, number, #0.00%}", tempPnl, tempPnl/tradeSize))
    label.set_tooltip(activeTradeLabel, str.format("{0}\n{1}\n{2}\n⟶ {3, number, #0.00%} RoI", activeTradeInfo, (remainingExitQty > 0 ? str.format("{0} Balance Units\n", remainingExitQty) : ""), chargeDescrption, tempPnl/tradeSize))

if withinTestRange
     and (didLongPositionClose or didShortPositionClose)
     
    realtime := 0.0

    if includeBrokerage
        float averageExitPrice = ((entryPrice * qty) + pnl) / qty
        if applyIndianBrokerageStructure
            [_charges, _chargeDesc] = vault.calculateCharges(entryPrice, averageExitPrice, qty, f_tradeDirection(inLongTrade, inShortTrade), makerFee, takerFee,
                                                                 flatFee = flatFee,
                                                                 txnFee = exchangeTxnFee,
                                                                 stt = stt,
                                                                 gst = gst,
                                                                 turnoverFee = turnoverFee,
                                                                 stampDuty = stampDuty)
            totalCharges := _charges
            chargeDescrption := _chargeDesc
        else
            [_charges, _chargeDesc] = vault.calculateCharges(entryPrice, averageExitPrice, qty, f_tradeDirection(inLongTrade, inShortTrade), makerFee, takerFee)
            totalCharges := _charges
            chargeDescrption := _chargeDesc
    
    label.set_color(activeTradeLabel, (pnl > 0 ? pnlLabelProfitBgColor : pnlLabelLossBgColor))
    label.set_textcolor(activeTradeLabel, (pnl > 0 ? pnlLabelProfitColor : pnlLabelLossColor))
    label.set_text(activeTradeLabel, str.format("{0, number, currency}\n{1, number, #0.00%}", pnl, pnl/tradeSize))
    label.set_tooltip(activeTradeLabel, str.format("{0}\n{1}\n⟶ {2, number, #0.00%} RoI", activeTradeInfo, chargeDescrption, pnl/tradeSize))
    
    totalTrades := totalTrades + 1
    
    pnl := pnl - totalCharges
    totalPnl := totalPnl + pnl
    totalPnlPercent := totalPnlPercent + (pnl/tradeSize)
    if pnl > 0
        winners := winners + 1
        maxProfit := maxProfit < pnl ? pnl : maxProfit
        totalProfit := totalProfit + pnl

        coldStreak := 0
        hotStreak := hotStreak + 1
        maxHotStreak := maxHotStreak < hotStreak ? hotStreak : maxHotStreak

        coldStreakLoss := 0.0
        hotStreakGains := hotStreakGains + (pnl/tradeSize)
        maxHotStreakGains := maxHotStreakGains < hotStreakGains ? hotStreakGains : maxHotStreakGains
    else
        loosers := loosers + 1
        maxLoss := maxLoss > pnl ? pnl : maxLoss
        totalLoss := totalLoss + pnl
        
        hotStreak := 0
        coldStreak := coldStreak + 1
        maxColdStreak := maxColdStreak < coldStreak ? coldStreak : maxColdStreak
        
        hotStreakGains := 0.0
        coldStreakLoss := coldStreakLoss + (pnl/tradeSize)
        maxColdStreakLoss := maxColdStreakLoss > coldStreakLoss ? coldStreakLoss : maxColdStreakLoss
    
    cumulativeCapital := cumulativeCapital + tradeSize
    maxCapital := maxCapital < tradeSize ? tradeSize : maxCapital
    
    prevPnl := pnl
    prevPnlPercent := 100*pnl/tradeSize
    
    if tradeSize == maxCapital
        if maxCapitalLabel != na
            label.set_color(maxCapitalLabel, maxCapitalLabelBgColor)
            label.set_textcolor(maxCapitalLabel, maxCapitalLabelTextColor)
            
        maxCapitalLabelBgColor := (pnl > 0 ? pnlLabelProfitBgColor : pnlLabelLossBgColor)
        maxCapitalLabelTextColor := (pnl > 0 ? pnlLabelProfitColor : pnlLabelLossColor)
        maxCapitalLabel := activeTradeLabel
        label.set_color(activeTradeLabel, pnlLabelMaxCapitalColor)
        label.set_textcolor(activeTradeLabel, pnlLabelMaxCapitalTextColor)
    
    activeTradeLabel := na
    activeTradeInfo := na
    qty := 0.0
    qtyPerExit := 0.0
    qtyPerTakeProfit := 0.0
    qtyPerRsiExit := 0.0
    remainingExitQty := 0.0
    pnl := 0.0
    tradeSize := 0.0
    
    shouldExitOnRibbonCross := false
    shouldExitOnEmaCross := false
    shouldExitOnRibbonTwist := false
    shouldExitOnStop := false
    shouldTakeProfit := false
    didTakeProfit := false
    shouldExitPreemptively := false
    shouldExitOnRsi := false
    didExitOnRsi := false
    
    entryPrice := 0.0
    entryBar := -1
    
    stopLoss := 0.0
    stopLossBar := -1
    breakevenTrigger := 0.0
    takeProfit := 0.0
    takeProfitBar := -1
    emaExit1 := 0.0
    emaExit2 := 0.0
    emaExit3 := 0.0
    emaExit4 := 0.0
    emaExit5 := 0.0
    emaExit6 := 0.0
    emaExit7 := 0.0
    emaExit8 := 0.0
    emaExit9 := 0.0
    emaExit10 := 0.0
    ribbonExit := 0.0
    tkCrossExit := 0.0
    preemptiveExit := 0.0
    chikouExit := 0.0
    
    stopLossQty := 0.0
    takeProfitQty := 0.0
    emaExitQty1 := 0.0
    emaExitQty2 := 0.0
    emaExitQty3 := 0.0
    emaExitQty4 := 0.0
    emaExitQty5 := 0.0
    emaExitQty6 := 0.0
    emaExitQty7 := 0.0
    emaExitQty8 := 0.0
    emaExitQty9 := 0.0
    emaExitQty10 := 0.0
    ribbonExitQty := 0.0
    tkCrossExitQty := 0.0
    preemptiveExitQty := 0.0
    chikouExitQty := 0.0
    
    stopLossGains := 0.0
    takeProfitGains := 0.0
    emaExitGains1 := 0.0
    emaExitGains2 := 0.0
    emaExitGains3 := 0.0
    emaExitGains4 := 0.0
    emaExitGains5 := 0.0
    emaExitGains6 := 0.0
    emaExitGains7 := 0.0
    emaExitGains8 := 0.0
    emaExitGains9 := 0.0
    emaExitGains10 := 0.0
    ribbonExitGains := 0.0
    tkCrossExitGains := 0.0
    preemptiveExitGains := 0.0
    chikouExitGains := 0.0

    hasSignaled := false


//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░██████╗░██╗░██████╗██████╗░██╗░░░░░░█████╗░██╗░░░██╗░░
//░░██╔══██╗██║██╔════╝██╔══██╗██║░░░░░██╔══██╗╚██╗░██╔╝░░
//░░██║░░██║██║╚█████╗░██████╔╝██║░░░░░███████║░╚████╔╝░░░
//░░██║░░██║██║░╚═══██╗██╔═══╝░██║░░░░░██╔══██║░░╚██╔╝░░░░
//░░██████╔╝██║██████╔╝██║░░░░░███████╗██║░░██║░░░██║░░░░░
//░░╚═════╝░╚═╝╚═════╝░╚═╝░░░░░╚══════╝╚═╝░░╚═╝░░░╚═╝░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// Display PnL summary
var table pnlTable = table.new(position.bottom_right, 7, 3, bgcolor = color.rgb(0, 0, 0, 30), frame_color = color.black)
if (barstate.islast and showPnl)
    table.cell(pnlTable, 0, 0, "Winners (HS)", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 0, 1, str.format("{0} ({1})", winners, maxHotStreak), text_color = color.green, text_halign = text.align_center, text_size = size.small)
    table.cell(pnlTable, 0, 2, str.format("{0, number, currency}\n({1, number, #0.00%})", maxProfit, maxHotStreakGains), text_halign = text.align_center, text_color = color.rgb(182, 209, 186), text_size = size.small)
    table.cell(pnlTable, 1, 0, "Loosers (CS)", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 1, 1, str.format("{0} ({1})", loosers, maxColdStreak), text_color = color.red, text_halign = text.align_center, text_size = size.small)
    table.cell(pnlTable, 1, 2, str.format("{0, number, currency}\n({1, number, #0.00%})", maxLoss, maxColdStreakLoss), text_halign = text.align_center, text_color = color.rgb(182, 153, 153), text_size = size.small)
    table.cell(pnlTable, 2, 0, "Total", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 2, 1, str.tostring(totalTrades), text_halign = text.align_center, text_color = color.silver, text_size = size.small)
    table.cell(pnlTable, 2, 2, str.format("{0, number, percent}", winners/totalTrades), text_halign = text.align_center, text_color = color.blue, text_size = size.small)
    table.cell(pnlTable, 3, 0, "W/L-PnL (Avg)", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 3, 1, str.format("{0, number, currency}\n({1, number, currency})", totalProfit, totalProfit/winners), text_halign = text.align_center, text_color = color.rgb(182, 209, 186), text_size = size.small)
    table.cell(pnlTable, 3, 2, str.format("{0, number, currency}\n({1, number, currency})", totalLoss, totalLoss/loosers), text_halign = text.align_center, text_color = color.rgb(182, 153, 153), text_size = size.small)
    table.cell(pnlTable, 4, 0, "Total PnL (Avg)", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 4, 1, str.format("{0, number, currency}\n({1, number, currency})", totalPnl, totalPnl/totalTrades), text_halign = text.align_center, text_color =  (totalPnl > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
    table.cell(pnlTable, 4, 2, str.format("{0, number, #0.00%}\n({1, number, #0.00%})", totalPnlPercent, totalPnlPercent/totalTrades), text_halign = text.align_center, text_color =   (totalPnlPercent > 0 ? color.green : color.red), text_size = size.small)
    table.cell(pnlTable, 5, 0, "Days", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 5, 1, str.format("{0, number}", (toDateInput - fromDateInput)/ (24 * 60 * 60 * 1000)), text_halign = text.align_center, text_color = color.silver, text_size = size.small)
    table.cell(pnlTable, 5, 2, str.tostring(totalCandles), text_halign = text.align_center, text_color = color.gray, text_size = size.small)
    table.cell(pnlTable, 6, 0, "Capital", text_halign = text.align_center, text_color = color.white, text_size = size.small)
    table.cell(pnlTable, 6, 1, str.format("{0, number, currency}", maxCapital), text_halign = text.align_center, text_color = color.silver, text_size = size.small)
    table.cell(pnlTable, 6, 2, str.format("{0, number, currency}", cumulativeCapital/totalTrades), text_halign = text.align_center, text_color = color.gray, text_size = size.small)

// Display trade information
if showTradePlan and horizontalTradePlan
    var table tradeTable = table.new(position.bottom_left, 17, 4, bgcolor = color.rgb(0, 0, 0, 30), frame_width = 2, frame_color = color.black)
    if (barstate.islast)
        table.cell(tradeTable, 1, 0, "Entry", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 2, 0, "TP", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 3, 0, "Exit 1", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 4, 0, "Exit 2", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 5, 0, "Exit 3", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 6, 0, "Exit 4", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 7, 0, "Exit 5", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 8, 0, "Exit 6", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 9, 0, "Exit 7", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 10, 0, "Exit 8", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 11, 0, "Exit 9", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 12, 0, "Exit 10", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 13, 0, "C.Exit", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 14, 0, "K.Exit", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 15, 0, "SL/PnL", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 16, 0, "Qty/%", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 1, (inLongTrade ? "Buy" : ( inShortTrade ? "Sell" : "-")), text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 1, 1, str.tostring(entryPrice, str.tostring(util.tickFormat())), text_color = color.blue, text_size = size.small)
        table.cell(tradeTable, 2, 1, str.tostring(inLongTrade ? takeProfit : takeProfit, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 3, 1, str.tostring(emaExit1, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 4, 1, str.tostring(emaExit2, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 5, 1, str.tostring(emaExit3, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 6, 1, str.tostring(emaExit4, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 7, 1, str.tostring(emaExit5, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 8, 1, str.tostring(emaExit6, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 9, 1, str.tostring(emaExit7, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 10, 1, str.tostring(emaExit8, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 11, 1, str.tostring(emaExit9, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 12, 1, str.tostring(emaExit10, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 13, 1, str.tostring(chikouExit, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 14, 1, str.tostring(ribbonExit, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 15, 1, str.format("{0, number, currency}", stopLoss), text_color = color.orange, text_size = size.small)
        table.cell(tradeTable, 16, 1, str.format("{0, number, #0.0000}", qty), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 0, 2, "+/-", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 1, 2, str.format("{0,number,currency}", tradeSize), text_color = color.aqua, text_size = size.small)
        table.cell(tradeTable, 2, 2, str.tostring(takeProfitGains, str.tostring(util.tickFormat())), text_color = (takeProfitGains > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 3, 2, str.tostring(emaExitGains1, str.tostring(util.tickFormat())), text_color = (emaExitGains1 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 4, 2, str.tostring(emaExitGains2, str.tostring(util.tickFormat())), text_color = (emaExitGains2 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 5, 2, str.tostring(emaExitGains3, str.tostring(util.tickFormat())), text_color = (emaExitGains3 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 6, 2, str.tostring(emaExitGains4, str.tostring(util.tickFormat())), text_color = (emaExitGains4 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 7, 2, str.tostring(emaExitGains5, str.tostring(util.tickFormat())), text_color = (emaExitGains5 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 8, 2, str.tostring(emaExitGains6, str.tostring(util.tickFormat())), text_color = (emaExitGains6 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 9, 2, str.tostring(emaExitGains7, str.tostring(util.tickFormat())), text_color = (emaExitGains7 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 10, 2, str.tostring(emaExitGains8, str.tostring(util.tickFormat())), text_color = (emaExitGains8 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 11, 2, str.tostring(emaExitGains9, str.tostring(util.tickFormat())), text_color = (emaExitGains9 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 12, 2, str.tostring(emaExitGains10, str.tostring(util.tickFormat())), text_color = (emaExitGains10 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 13, 2, str.tostring(chikouExitGains, str.tostring(util.tickFormat())), text_color = (ribbonExitGains > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 14, 2, str.tostring(ribbonExitGains, str.tostring(util.tickFormat())), text_color = (ribbonExitGains > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 15, 2, str.format("{0, number, currency}", pnl+realtime-totalCharges), text_color = (pnl+realtime-totalCharges > 0 ? color.green : color.red), text_size = size.small)
        table.cell(tradeTable, 16, 2, str.format("{0, number, #0.00%}", (pnl+realtime-totalCharges)/tradeSize), text_color = (pnl+realtime-totalCharges > 0 ? color.green : color.red), text_size = size.small)
else if showTradePlan
    var table tradeTable = table.new(position.bottom_left, 4, 17, bgcolor = color.rgb(0, 0, 0, 30), frame_width = 2, frame_color = color.black)
    if (barstate.islast)
        table.cell(tradeTable, 0, 1, "Entry", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 2, "TP", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 3, "Exit 1", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 4, "Exit 2", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 5, "Exit 3", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 6, "Exit 4", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 7, "Exit 5", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 8, "Exit 6", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 9, "Exit 7", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 10, "Exit 8", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 11, "Exit 9", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 12, "Exit 10", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 13, "C.Exit", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 14, "K.Exit", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 15, "SL/PnL", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 0, 16, "Qty/%", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 1, 0, (inLongTrade ? "Buy" : ( inShortTrade ? "Sell" : "-")), text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 1, 1, str.tostring(entryPrice, str.tostring(util.tickFormat())), text_color = color.blue, text_size = size.small)
        table.cell(tradeTable, 1, 2, str.tostring(inLongTrade ? takeProfit : takeProfit, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 3, str.tostring(emaExit1, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 4, str.tostring(emaExit2, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 5, str.tostring(emaExit3, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 6, str.tostring(emaExit4, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 7, str.tostring(emaExit5, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 8, str.tostring(emaExit6, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 9, str.tostring(emaExit7, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 10, str.tostring(emaExit8, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 11, str.tostring(emaExit9, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 12, str.tostring(emaExit10, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 13, str.tostring(chikouExit, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 14, str.tostring(ribbonExit, str.tostring(util.tickFormat())), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 1, 15, str.format("{0, number, currency}", stopLoss), text_color = color.orange, text_size = size.small)
        table.cell(tradeTable, 1, 16, str.format("{0, number, #0.0000}", qty), text_color = color.gray, text_size = size.small)
        table.cell(tradeTable, 2, 0, "+/-", text_color = color.white, text_size = size.small)
        table.cell(tradeTable, 2, 1, str.format("{0, number, currency}", tradeSize), text_color = color.aqua, text_size = size.small)
        table.cell(tradeTable, 2, 2, str.tostring(takeProfitGains, str.tostring(util.tickFormat())), text_color = (takeProfitGains > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 3, str.tostring(emaExitGains1, str.tostring(util.tickFormat())), text_color = (emaExitGains1 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 4, str.tostring(emaExitGains2, str.tostring(util.tickFormat())), text_color = (emaExitGains2 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 5, str.tostring(emaExitGains3, str.tostring(util.tickFormat())), text_color = (emaExitGains3 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 6, str.tostring(emaExitGains4, str.tostring(util.tickFormat())), text_color = (emaExitGains4 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 7, str.tostring(emaExitGains5, str.tostring(util.tickFormat())), text_color = (emaExitGains5 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 8, str.tostring(emaExitGains6, str.tostring(util.tickFormat())), text_color = (emaExitGains6 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 9, str.tostring(emaExitGains7, str.tostring(util.tickFormat())), text_color = (emaExitGains7 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 10, str.tostring(emaExitGains8, str.tostring(util.tickFormat())), text_color = (emaExitGains8 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 11, str.tostring(emaExitGains9, str.tostring(util.tickFormat())), text_color = (emaExitGains9 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 12, str.tostring(emaExitGains10, str.tostring(util.tickFormat())), text_color = (emaExitGains10 > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 13, str.tostring(chikouExitGains, str.tostring(util.tickFormat())), text_color = (ribbonExitGains > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 14, str.tostring(ribbonExitGains, str.tostring(util.tickFormat())), text_color = (ribbonExitGains > 0 ? color.rgb(182, 209, 186) : color.rgb(182, 153, 153)), text_size = size.small)
        table.cell(tradeTable, 2, 15, str.format("{0, number, currency}", pnl+realtime-totalCharges), text_color = (pnl+realtime-totalCharges > 0 ? color.green : color.red), text_size = size.small)
        table.cell(tradeTable, 2, 16, str.format("{0, number, percent}", (pnl+realtime-totalCharges)/tradeSize), text_color = (pnl+realtime-totalCharges > 0 ? color.green : color.red), text_size = size.small)

